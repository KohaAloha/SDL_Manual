=head0 The Game Loop 

=head1 Simplest Game Loop

The simplest game loop can be boiled down to the following. 

=for programlisting

    while(!$quit)
    {
       get_events();
       calculate_next_positions();
       render();
    }

=for programlisting

In C<get_events()> we get events from what input devices that we need. It is important to process events first to prevent lag.
In C<calculate_next_positions> we update the game state according to animations and the events captured. In C<render()> we will update the screen and show the game to the player. 

A practical example of this is a moving Lazer. 

    use strict;
    use warnings;
    use SDL;
    use SDL::Event;
    use SDL::Events;
    use SDLx::App;
    
    my $app = SDLx::App->new( 
                             width=> 200, height => 200,
                             title=> 'Pew Pew'
                            );

    #Don't need to quit yet
    my $quit = 0;
    #Start lazer on the left
    my $lazer = 0;
    sub get_events{ 

                    my $event = SDL::Event->new();
                    
                    #Pump the event queue
                    SDL::Events::pump_events;

                    while( SDL::Events::poll_event($event) )
                    {
                        $quit = 1 if $event->type == SDL_QUIT  
                    }
                  }

    sub calculate_next_positions{
        $lazer++;
    }
    
    sub render { 
        
        #Draw the background first
        $app->draw( [0,0,$app->w, $app->h], 0 );

        #Draw the lazer
        $app->draw( [$lazer, $app->h/2, 10, 2], [255,0,0,255]);

        $app->update();

    }

    while(!$quit)
    {
         get_events();
         calculate_next_positions();
         render();
    }

=head2 Issues

This game loop works really well for consoles and devices where the CPU clock speed is always known. All of your user will be using the 
processor to run this code. This means that each animation and calculation will happen at the exact same time in each machine. This is
a critical assumption when we have users with various CPU clock speeds. For faster CPU this means that all animations, calculations and 
generally the whole game will be really fast, and hard for the user to play.

=head1 Fixed FPS

One way to solve this problem is to fix the Frames Per Second your game runs at. The frame is defined by each new redraw of the screen.
What we can do is keep track of the number of frames we are having and divide it by the time elapsed from the last frame sample. 

=head2 Exercise 
First run the below script with no fps fixing:

    perl game_fixed.pl

You will see that the FPS is erratic, and the laser seems to speed up and slow down randomly.

Next fix the upper bounds of the FPS

    perl game_fixed.pl 1

This will prevent the laser from going too fast, in this case faster then 60 frames per second.

Finally adding the fix the lower bounds of the FPS

    perl game_fixed.pl 1 1

At this point the FPS should be at a steady 60 frames per second. However if this is not the case
read on to the problems below.


	use strict;
	use warnings;
	use SDL;
	use SDL::Event;
	use SDL::Events;
	use SDLx::App;

	my $app = SDLx::App->new(
			width  => 200,
			height => 200,
			title  => 'Pew Pew'
			);

	# Variables 
	# to save our start/end and delta times for each frame
	# to save our frames and FPS 
	my ( $start, $end, $delta_time, $FPS, $frames ) = ( 0, 0, 0, 0, 0 );

	# We will aim for a rate of 60 frames per second 
	my $fixed_rate = 60;

	# Our times are in micro second, so we will compenstate for it
	my $fps_check = (1000/ $fixed_rate );

	#Don't need to quit yet
	my $quit = 0;

	#Start lazer on the left
	my $lazer = 0;

	sub get_events {

		my $event = SDL::Event->new();

	#Pump the event queue
		SDL::Events::pump_events;

		while ( SDL::Events::poll_event($event) ) {
			$quit = 1 if $event->type == SDL_QUIT;
		}
	}

	sub calculate_next_positions {
		$lazer++;

		$lazer = 0 if $lazer > $app->w;
	}

	sub render {

	#Draw the background first
		$app->draw_rect( [ 0, 0, $app->w, $app->h ], 0 );

	#Draw the lazer
		$app->draw_rect( [ $lazer, $app->h / 2, 10, 2 ], [ 255, 0, 0, 255 ] );

	#Draw our FPS on the screen so we can see
		$app->draw_gfx_text( [ 10, 10 ], [ 255, 0, 255, 255 ], "FPS: $FPS" );

		$app->update();
	}


	# Called at the end of each frame, wether we draw or not
	sub calculate_fps_at_frame_end
	{

		# Ticks are microseconds since load time
		$end = SDL::get_ticks();

		# We will average our frame rate over 10 frames, to give less erratic rates
		if ( $frames < 10 ) {
			
			#Count a frame
			$frames++;
			
			#Calculate how long it took from the start 
			$delta_time += $end - $start;
		}
		else {

			# Our frame rate is our  Frames * 100 / Time Elapsed in us
			$FPS        = int( ( $frames * 100 ) / $delta_time );

			# Reset our metrics
			$frames     = 0;
			$delta_time = 0;
		}



	}

	while ( !$quit ) {


		# Get the time for the starting of the frame
		$start = SDL::get_ticks();

		get_events();

		# If we are fixing the lower bounds of the frame rate
		if( $ARGV[1] )
		{

			# And our delta time is going too slow for frame check
			if ( $delta_time > $fps_check ) {

				# Calculate our FPS from this 
				calculate_fps_at_frame_end();

				# Skip rendering and collision detections 
				# The heavy functions in the game loop
				next;		  

			}

		}


		calculate_next_positions();
		render();

		# A normal frame with rendering actually performed
		calculate_fps_at_frame_end();

		# if we are fixing the upper bounds of the frame rate
		if ( $ARGV[0] ) {
			
			# and our delta time is going too fast compared to the frame check
			if ( $delta_time < $fps_check ) {

				# delay for the difference
				SDL::delay( $fps_check - $delta_time );
			}
		}


	}

=head2 Problems

Generally this method is sufficient for most computers out there. The animations will be consistent
enough that we see the same thing on differing CPU, in terms of speed. However there are some serious
problems with this method. First if a computer is too slow for 60 frames for second it will skip a
lot of rendering, and the animation will look sparse and jittery. Maybe it would be better for 30 fps
or lower for that machine, which is hard for the developer to predict. Secondly if a CPU is fast, a 
lot of CPU cycles are wasted in the delay. 

Finally this method does not fix the fundamental problem that the rendering is fixed to CPU clock speed.

=head2 Potential Fix: Variable FPS

One way to fix the problem of a computer being consistently faster or slower for the default Frame per 
Second set, is to change the FPS accordingly. So far a slow CPU it will jump down to 30 FPS and so on. 
In the author opinion, although a consistent FPS is achieved, it still presents the problem of differing
animation speeds for different CPUs. 

=head1 Integrating Physics

Looks goods

=head2 Problems

but ok.

=head1 Learn More

=for vim: spell
