=head0 Tetris 

=head1 The Game Window

First we will make our window with a fixed size so we can place our art work
in a fixed format.

   use strict;
   use warnings;

   use SDL;
   use SDL::Event;
   use SDL::Events;
   use SDLx::App;

   # create our main screen
   my $app = SDLx::App->new(
      w            => 400,
      h            => 512,
      exit_on_quit => 1,
      dt           => 0.2,
      title        => 'SDLx Tetris'
   );

=head1 Loading Artwork 

We can load our artwork simply by storing an array of C<SDLx::Surface>s.

   use SDL;
   +use SDLx::Surface;
   
   ...

   +my $back  = SDLx::Surface->load( 'data/tetris_back.png' );
   +my @piece = (undef);
   +push(@piece, SDLx::Surface->load( "data/tetris_$_.png" )) for(1..7);

The background is held in the C<$back> surface, and the pieces are held in the 
C<@piece> array. Later on we will blit these onto our main screen as we need.


=head1 Data Structures

In Tetris the blocks are critical pieces of data that must be represented in code 
such that it is easy to access, and quick to perform calculations on. A hash will 
allow us to quickly access our pieces, based on their keys. 


   my %pieces = (
      I => [0,5,0,0,
           0,5,0,0,
           0,5,0,0,
           0,5,0,0],
      J => [0,0,0,0,
           0,0,6,0,
           0,0,6,0,
           0,6,6,0],
      L => [0,0,0,0,
           0,2,0,0,
           0,2,0,0,
           0,2,2,0],
      O => [0,0,0,0,
           0,3,3,0,
           0,3,3,0,
           0,0,0,0],
      S => [0,0,0,0,
           0,4,4,0,
           4,4,0,0,
           0,0,0,0],
      T => [0,0,0,0,
           0,7,0,0,
           7,7,7,0,
           0,0,0,0],
      Z => [0,0,0,0,
           1,1,0,0,
           0,1,1,0,
           0,0,0,0],
   );

Further more we have a 1-dimensional array for each piece that represents a grid of the piece.

The grid of each piece is filled with empty spaces and a number from 1 to 7. When this grid is 
imposed on the game grid, we can use the non zero number to draw the write piece block on to it.

=head1 Game flow

=head2 Considerations

=head3 Refactor the first draft

=head1 Collisions

What is colliding to what?

=head2 Considerations

=head3 Dynamic 

Are both colliers going to collide?

=head3 Direction of Collisions

Multiple directions of collisions?

=head3 Game Events

Should they trigger a game event? React?

=head2 The Game





=for vim: spell
