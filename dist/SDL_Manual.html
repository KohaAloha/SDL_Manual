<h1>Preface</h1>

<p><i>Simple DirectMedia Layer</i> (or <i>libsdl</i>) is a cross-platform C
library that provides access to several input and output devices. Its most
popular usage is to provide access to the video framebuffer and input
devices for games. SDL also has several extension libraries to provide
features such as text display, sound mixing, image handling, and graphics
effects.</p>

<p>SDL Perl binds several of these libraries together in the
<code>SDL::*</code> namespace. Moreover, SDL Perl provides several
high-level libraries in the <code>SDLx::*</code> namespace that encapsulate
valuable game-writing abstractions.</p>

<h2><code>SDL</code> and <code>SDLx</code></h2>

<p>The main purpose of the <code>SDLx::*</code> layer is to smooth out the
drudgery of using the <code>SDL::*</code> layer directly.</p>

<blockquote>

<p>Don't worry about understanding the details of this code right now.
Compare the complexity and size of the code listings.</p>

</blockquote>

<p>Using the <code>SDL::*</code> layer to draw a blue rectangle looks
something like:</p>

<pre><code>    use SDL;
    use SDL::Video;
    use SDL::Surface;
    use SDL::Rect;

    # the size of the window box or the screen resolution if fullscreen
    my $screen_width   = 800;
    my $screen_height  = 600;

    SDL::init(SDL_INIT_VIDEO);

    # setting video mode
    my $screen_surface = SDL::Video::set_video_mode($screen_width,
                                                    $screen_height,
                                                    32,
                                                    SDL_ANYFORMAT);

    # drawing a rectangle with the blue color
    my $mapped_color   = SDL::Video::map_RGB($screen_surface-&gt;format(),
                                              0, 0, 255);
    SDL::Video::fill_rect($screen_surface,
                          SDL::Rect-&gt;new($screen_width / 4, $screen_height / 4,
                                         $screen_width / 2, $screen_height / 2),
                          $mapped_color);

    # update an area on the screen so it&#39;s visible
    SDL::Video::update_rect($screen_surface, 0, 0,
                            $screen_width, $screen_height);

    # just to have time to see it
    sleep(5);</code></pre>

<p>... while drawing a blue rectangle in the <code>SDLx::*</code> layer is
as simple as:</p>

<pre><code>    use strict;
    use warnings;

    use SDL;
    use SDLx::App;

    my $app = SDLx::App-&gt;new( width=&gt; 800, height =&gt; 600 );

    $app-&gt;draw_rect([ $app-&gt;width / 4, $app-&gt;height / 4,
                      $app-&gt;width / 2, $app-&gt;height / 2, ],
                      [ 0, 0, 255, 255] );

    $app-&gt;update();

    sleep(5);</code></pre>

<p>The <code>SDLx::*</code> modules also provide and manage higher-level
concerns for users, such as layers and game loops.</p>

<h2>About the Book</h2>

<p>This book has a two-fold purpose: first, to introduce game development
to Perl programmers, and second, to introduce Modern Perl concepts through
game development. While the examples assume some experience with Perl, no
experience with SDL in Perl or as <code>libsdl</code> itself is
necessary.</p>

<p>The book presents a progression from simple to intermediate examples and
provides suggestions for more advanced endeavors. The chapters of this book
increase progressively in complexity, but each chapter has a singular goal
(such as chapter five's <i>Making Pong</i>) which stands alone as an
individual tutorial. Sources and data files are all available from
http://sdl.perl.org/.</p>

<h2>Installing SDL Perl</h2>

<p>We assume the presence of a recent version of the Perl language (at
least Perl 5.10) and supporting packages. We also assume that you can
install packages from the CPAN, including SDL Perl itself.</p>

<h3>Windows</h3>

<p><code>Alien::SDL</code> will install binaries for 32bit and 64bit so
there is no need to compile anything.</p>

<h3>Mac OS X</h3>

<p>Fink has packages for SDL Perl available. However, they do not support
Pango, a library which provides internalization support for text
handling.</p>

<p>Installing <code>Alien::SDL</code> from the CPAN will compile SDL and
its dependencies, provided you have installed severan necessary
dependencies. We recommend that you install <code>libfreetype6</code>,
<code>libX11</code>, <code>libvorbis</code>, <code>libogg</code>,
<code>libpng</code>, and their headers.</p>

<h3>GNU/Linux</h3>

<p>Most current GNU/Linux distributions include all the parts needed for
this tutorial in the default install and in their package management
system. It is also always possible to install on GNU/Linux using the
available open source code from the proper repositories. The
<code>Alien::SDL</code> perl module automates much of downloading,
compiling, and installing the needed libraries.</p>

<p>You can probably use your distribution's packages. On Ubuntu and Debian
try:</p>

<pre><code>    $ sudo apt-get install libsdl-net1.2-dev libsdl-mixer1.2-dev \
    libsdl1.2-dev libsdl-image1.2-dev libsdl-ttf2.0-dev \
    libsdl-gfx1.2-dev libsdl-pango-dev</code></pre>

<p>To compile from scratch, you must install a compiler, system header
packages, and some libraries are required.</p>

<pre><code>    $ sudo apt-get install build-essential xorg-dev libx11-dev libxv-dev \
    libpango1.0-dev libfreetype6-dev libvorbis-dev libpng12-dev \
    libogg-dev</code></pre>

<h3>CPAN install</h3>

<p>Before installing SDL Perl, ensure that you have the most recent
versions of the modules necessary to build SDL:</p>

<pre><code>    $ sudo cpan CPAN
    $ sudo cpan YAML Module::Build</code></pre>

<p>After these two steps CPAN will be able to install SDL:</p>

<pre><code>    $ sudo cpan SDL</code></pre>

<p>For most platforms a CPAN install will suffice. Supported and tested
platforms are listed at http://pass.cpantesters.org/distro/S/SDL.html.</p>

<h2>Contact</h2>

<p>Hopefully this book answers most of your questions. For additional
assistance, contact the project via:</p>

<ul>

<li><i>the web</i>, by visiting the SDL Perl homepage at
http://sdl.perl.org/.</li>

<li><i>IRC</i>, in the <code>#sdl</code> channel on
<code>irc.perl.org</code>. This is a very active and helpful resource.</li>

<li><i>email</i>, through the <code>sdl-devel@perl.org</code> mailing
list.</li>

</ul>

<h2>Examples</h2>

<p>The code examples in this book are available from
https://github.com/PerlGameDev/SDL_Manual/tree/master/code_listings.</p>

<h2>Acknowledgements</h2>

<p>Thanks to contributors and reviewers from the <code>#sdl</code> channel,
including:</p>

<ul>

<li>Alias

<li>bobross

<li>Blaizer

<li>cfedde

<li>chromatic

<li>FROGGS

<li>garu

<li>jamesw

<li>perlpilot

<li>PerlJam

<li>Pip

<li>waxhead

<li>and many more

<pre><code>    (Apologies if I have missed you; let me know and I will add you.)</code></pre>

</ul>

<h1>The Screen</h1>

<p>   </p>

<p>SDL's primary purpose is to display graphics. It does so by providing an
abstraction called a <i>screen</i>, which represents a <i>video device</i>.
This video device is an interface provided by your operating system, such
as X11 or DirectX. Before you can display anything, you must create a
screen. The <code>SDLx::App</code> class does so for you:</p>

<pre><code>    use strict;
    use warnings;
    use SDL;
    use SDLx::App;

    my $app = SDLx::App-&gt;new();

    sleep( 2 );</code></pre>

<p>This example causes an empty window to appear on the desktop. Most
systems will fill that window with the color black. Other systems might
display a transparent window. SDL's default behavior is to fill the screen
with black. To enforce this behavior on all systems, you must
<code>update()</code> the app to draw to the window:</p>

<pre><code>    $app-&gt;update();</code></pre>

<h2><code>SDLx::App</code> Options</h2>

<p><code>SDLx::App</code> allows you to specify several options for the
screen and your application. First are the physical dimensions of the
screen itself. To make the screen of the <code>SDLx::App</code> window a
400Ã—400 pixel square, change the initialization line to:</p>

<pre><code>    my $app = SDLx::App-&gt;new( width =&gt; 400, height =&gt; 400 );</code></pre>

<p>Another important option is the window's title. Some systems display the
path to the running program. Others leave the title blank. You can change
the displayed title with another argument to the <code>SDLx::App</code>
constructor:</p>

<pre><code>    my $app = SDLx::App-&gt;new( width  =&gt; 400,
                              height =&gt; 400,
                              title  =&gt; &#39;Pong - A clone&#39; );</code></pre>

<p>At this point your screen will be:</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/first.png}
\caption{Your first SDL screen!} \label{fig:first_screen}</p>



<h3>Shortcuts</h3>

<p>Abbreviations for these parameters are available. Instead of
<code>width</code>, <code>height</code>, and <code>title</code>, you may
use <code>w</code>, <code>h</code>, and <code>t</code> respectively. The
previous example could also be written:</p>

<pre><code>    my $app = SDLx::App-&gt;new( w =&gt; 400,
                              h =&gt; 400,
                              t =&gt; &#39;Pong - A clone&#39; );</code></pre>

<h1>Drawing</h1>

<p>SDL provides several ways to draw graphical elements on the screen in
three general categories: primitives, images, and text. All drawing occurs
on a surface, represented by the <code>SDLx::Surface</code> class. Even the
<code>SDLx::App</code> is an <code>SDLx::Surface</code>. Though this means
it's possible to draw directly to the app's surface, there are several
advantages to drawing on multiple surfaces.</p>

<h2>Coordinates</h2>

<p>SDL's surface coordinate system has its origin (where both the x and y
coordinates have the value of zero) in the upper left corner. As the value
of x increases, the position moves to the right of the origin. As the value
of y increases, the position moves downward from the origin. The API always
lists coordinates in x, y order.</p>

<blockquote>

<p>The SDL library documentation has an extended discussion on coordinates:
http://sdltutorials.com/sdl-coordinates-and-blitting.</p>

</blockquote>

<h2>Drawing with SDL</h2>

<p>You can produce original pictures knowing little more than how to draw
to a surface with SDL:</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/flower.png}
\caption{A field of flowers} \label{fig:flowers}</p>



<h3>Surface Drawing Methods</h3>

<p>As mentioned earlier, all drawing in SDL requires a surface. The
<code>SDLx::Surface</code> object provides access to methods in the form
of:</p>

<pre><code>    $surface-&gt;draw_{something}( .... );</code></pre>

<p>Parameters to these methods are generally coordinates and colors,
provided as array references.</p>

<h4>Rectangular Parameters</h4>

<p>Some parameters are sets of coordinate positions and dimensions. For
example, parameters to describe a rectangle of <code>40x40</code> pixels
placed at <code>(20, 20)</code> pixel units on the screen make a
four-element array reference of x, y, width, height:</p>

<pre><code>    my $rect = [20, 20, 40, 40];</code></pre>

<h4>Color</h4>

<p></p>

<p>Need to document what the magnitude of the color and transparency values
mean.</p>

<p>SDL color parameters require four-element array references. The first
three numbers define the Red, Green, and Blue intensity of the color. The
final number defines the transparency of the color.</p>

<pre><code>    my $color = [255, 255, 255, 255];</code></pre>

<p>The magnitude of each color value determines how much of that color
component will be mixed into the resulting color. A 0 value specifies that
none of the color channel should be used while 255 specifies a maximum
intensity for a particular channel. The first value corresponds with the
Red channel, so a higher number there means more red will be mixed into the
resulting color. It is a common practice to achieve a grayscale of varying
intensity by specifying the same value for each of the Red, Green, and Blue
color channels. The fourth and final value designates the transparency (or
Alpha channel) where a 0 value makes the resulting color fully transparent
and 255 makes it entirely opaque. A transparency value somewhere in between
will allow underlying (pixel data of surfaces below the current one) colors
to be blended with the specified RGB values into the final color
output.</p>

<p>You may also represent a color as hexadecimal values, where the values
of the numbers range from 0-255 for 32 bit depth in RGBA format:</p>

<pre><code>    my $color = 0xFFFFFFFF;
    my $white = 0xFFFFFFFF;
    my $black = 0x000000FF;
    my $red   = 0xFF0000FF;
    my $green = 0x00FF00FF;
    my $blue  = 0x0000FFFF;</code></pre>

<p>... or as four-byte hexadecimal values, where each two-digit byte
encodes the same RGBA values:</p>

<pre><code>    my $goldenrod = 0xDAA520FF;</code></pre>

<blockquote>

<h5>NOTE: Depth of Surface</h5>

<p>The color depth of the surface--how many bits are available to describe
colors--is a property of the relevant <code>SDLx::Surface</code> or
<code>SDLx::App</code>. Set it in its constructor:</p>

<pre><code>    my $app = SDLx::App-&gt;new( depth =&gt; 32 );</code></pre>

<p>The default bit depth is 32, such that each color component has 256
possible values. Other options are 24, 16, and 8.</p>

</blockquote>

<h3>Pixels</h3>

<p>All <code>SDLx::Surface</code>s are collections of pixels. You can read
from and write to these pixels by treating the surface as an array
reference:</p>

<pre><code>    $app-&gt;[$x][$y] = $color;</code></pre>

<p>... where <code>$color</code> is an unsigned integer value using the
hexadecimal format (<code>0xRRGGBBAA</code>) <i>or</i> an anonymous array
of the form <code>[$red, $green, $blue, $alpha]</code>.</p>

<h3>Primitives</h3>

<p></p>

<p>Drawing primitives are simple shapes that SDL supports natively.</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/draw-1.png}
\caption{Drawing a line} \label{fig:draw_line}</p>



<h4>Lines</h4>

<p>A line is a series of contiguous pixels between two points. The
<code>draw_line</code> method causes SDL to draw a line to a surface:</p>

<pre><code>    $app-&gt;draw_line( [200, 20], [20, 200], [255, 255, 0, 255] );</code></pre>

<p>This will draw a yellow line from positions <code>(200, 20)</code> to
<code>(20, 200)</code>.</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/draw-2.png}
\caption{Drawing a Rectangle} \label{fig:draw_rect}</p>



<h4>Rectangles</h4>

<p></p>

<p>A rectangle is a four-sided, filled polygon. Rectangles are a common
building block for games. In SDL, rectangles are the most cost effective of
the primitives to draw. The <code>draw_rect</code> method draws a rectangle
on a surface:</p>

<pre><code>    $app-&gt;draw_rect( [10, 20, 40, 40 ], [255, 255, 255,255] );</code></pre>

<p>This draws a white square of size <code>40x40</code> onto the screen at
the position <code>(10,20)</code>.</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/draw-3.png}
\caption{Drawing a Circle} \label{fig:draw_circle}</p>



<p>\includegraphics[width=0.5\textwidth]{../src/images/draw-4.png}
\caption{Drawing a filled Circle} \label{fig:draw_filled_circle}</p>



<h4>Circles</h4>

<p></p>

<p>A circle is a primitive a fixed radius around a given point. Circles may
be filled or unfilled. The <code>draw_circle</code> and
<code>draw_circle_filled</code> methods draw these to a surface:</p>

<pre><code>    $app-&gt;draw_circle(        [100, 100], 20, [255, 0,   0, 255] );
    $app-&gt;draw_circle_filled( [100, 100], 19, [0,   0, 255, 255] );</code></pre>

<p>These draw an unfilled red circle and a filled blue circle.</p>

<p>SDL provides more complex primitives in
<code>SDL::GFX::Primitives</code>.</p>

<h3>Drawing with Primitives</h3>

<p>It's easy to combine several primitives to draw an interesting
images.</p>

<pre><code>    use strict;
    use warnings;
    use SDL;
    use SDLx::App;

    my $app = SDLx::App-&gt;new(
        w     =&gt; 500,
        h     =&gt; 500,
        d     =&gt; 32,
        title =&gt; &#39;Pretty Flowers&#39;
    );

    # Add the blue skies
    $app-&gt;draw_rect( [ 0,   0, 500, 500 ], [ 20,  50, 170, 255 ] );

    # Draw a green field
    $app-&gt;draw_rect( [ 0, 400, 500, 100 ], [ 50, 170,  20, 100 ] );

    # Make a surface for the flower
    my $flower = SDLx::Surface-&gt;new( width =&gt; 50, height =&gt; 100 );

    # With a black background
    $flower-&gt;draw_rect( [  0,  0, 50, 100 ], [ 0,   0, 0,   0 ] );

    # Draw a pretty green stem
    $flower-&gt;draw_rect( [ 23, 30,  4, 100 ], [ 0, 255, 0, 255 ] );

    # And a simple flower bud
    $flower-&gt;draw_circle_filled( [ 25, 25 ], 10, [ 150, 0, 0, 255 ] );
    $flower-&gt;draw_circle(        [ 25, 25 ], 10, [ 255, 0, 0, 255 ] );

    # Draw flower on $app
    $flower-&gt;blit( $app, [ 0, 0, 50, 100 ] );

    $app-&gt;update();

    sleep(1);</code></pre>

<p>\includegraphics[width=0.5\textwidth]{../src/images/flower-1.png}
\caption{Looks so lonely there all alone} \label{fig:draw_flower_lone}</p>



<h2>Drawing on Multiple Surfaces</h2>

<p>The examples so far have drawn on only a single surface, the display.
SDL makes it possible to write on multiple surfaces. These other surfaces
exist only in memory until you draw them to the display.</p>

<h3>Creating Surfaces</h3>

<p>There are several ways to create an <code>SDLx::Surface</code> for use.
The most common is to create one manually with a constructor call:</p>

<pre><code>    $surface = SDLx::Surface-&gt;new( width =&gt; $width, height =&gt; $height );</code></pre>

<p><code>SDL::Image</code> and <code>SDL::Video</code> can load images as
surfaces too. <code>SDL::Image</code> provides support for all types of
images, provided that the underlying <code>SDL_image</code> library
supports the image type you want to load. For example,
<code>SDL_image</code> must support PNG images to use:</p>

<pre><code>    $surface = SDL::Image::load( &#39;picture.png&#39; );</code></pre>

<p>In the event that the desired <code>SDL_image</code> library is
unavailable, you can fallback to the built-in support for the
<code>.bmp</code> format.</p>

<pre><code>    $surface = SDL::Video::load_BMP( &#39;picture.bmp&#39; );</code></pre>

<p>The <code>SDLx::Sprite</code> module provides another option to
manipulate surfaces.</p>

<h2>Lots of Flowers but One Seed</h2>

<p>The flower example used a method called <code>blit</code> to draw a
surface to the display. This method copies data from one surface to
another. It's a fundamental operation, but it's a low level operation.
<code>SDLx::Sprite</code> provides higher level options. Besides making
drawing simpler, <code>SDLx::Sprite</code> adds several other features
useful for moving images. Here's a revised example using
<code>SDLx::Sprite</code> for flowers:</p>

<pre><code>    use strict;
    use warnings;
    use SDL;
    use SDLx::App;
    use SDLx::Sprite;

    my $app = SDLx::App-&gt;new(
        w     =&gt; 500,
        h     =&gt; 500,
        d     =&gt; 32,
        title =&gt; &#39;Pretty Flowers&#39;
    );

    # Adding blue skies
    $app-&gt;draw_rect( [ 0,   0, 500, 500 ], [ 20, 50, 170, 255 ] );

    # Draw a green field
    $app-&gt;draw_rect( [ 0, 400, 500, 100 ], [ 50, 170, 20, 100 ] );

    my $flower = SDLx::Sprite-&gt;new( width =&gt; 50, height =&gt; 100 );

    # Use -&gt;surface() to access a sprite&#39;s SDLx::Surface

    # Make the background black
    $flower-&gt;surface-&gt;draw_rect( [  0,  0, 50, 100 ], [ 0,   0, 0,   0 ] );

    # Now for a pretty green stem
    $flower-&gt;surface-&gt;draw_rect( [ 23, 30,  4, 100 ], [ 0, 255, 0, 255 ] );

    # Add the simple flower bud
    $flower-&gt;surface-&gt;draw_circle_filled( [ 25, 25 ], 10, [ 150, 0, 0, 255 ] );
    $flower-&gt;surface-&gt;draw_circle(        [ 25, 25 ], 10, [ 255, 0, 0, 255 ] );

    $flower-&gt;draw_xy( $app, 0, 0 );

    $app-&gt;update();

    sleep(1);</code></pre>

<p>Flowers usually don't grow in the sky. Flowers make more sense on the
ground. It's easy to insert plenty of identical flowers from a single
sprite. Replace the line:</p>

<pre><code>    $flower-&gt;draw_xy( $app, 0, 0 );</code></pre>

<p>... with:</p>

<pre><code>    for (0 .. 500) {
        my $y =           425 - rand( 50);
        $flower-&gt;draw_xy( $app, rand(500) - 20, $y );
    }</code></pre>

<p>... to make an entire field of flowers.</p>

<p>Probably don't need this.</p>

<h1>Handling Events</h1>

<p></p>

<p>The cornerstone of an SDL application is event handling. The user
presses a key or moves the mouse. The operating system switches the focus
of the active window. The user selects the quit option from the menu or the
operating system. These are all events. How do you handle them?</p>

<p> </p>

<p>SDL provides an event queue which holds all events that occur until they
are removed. Every time an event occurs, SDL places it into the queue. The
<code>SDL::Event</code> object represents this queue in Perl, allowing you
to add and remove events constantly:</p>

<pre><code>        use strict;
        use warnings;
        use SDL;
        use SDL::Event;
        use SDL::Events;
        use SDLx::App;

        my $app   = SDLx::App-&gt;new( w =&gt; 200, h =&gt; 200 );
        my $event = SDL::Event-&gt;new();
        
        my $quit  = 0;

        while (!$quit) {
        # Updates the queue to recent events
        SDL::Events::pump_events();

                # process all available events
                while ( SDL::Events::poll_event($event) ) {

                        # check by Event type
                        do_key() if $event-&gt;type == SDL_KEYDOWN;
                }
        }

        sub do_key { $quit = 1 }</code></pre>

<p>		  </p>

<p>Every event has an associated type which represents the category of the
event. The previous example looks for a keypress event	(footnote: SDL
separates the event of pressing a key from the event of releasing a key,
which allows you to identify combinations of keypresses, such as Ctrl + P
to print.). The SDL library defines several types of events, and SDL_perl
makes them available as constants with names such as
<code>SDL_KEYDOWN</code> and <code>SDL_QUIT</code>. See <code>perldoc
SDL::Events</code> for a list of all event types.</p>

<p></p>

<p>Checking for every possible event type within that event loop can be
tedious. The <code>SDLx::Controller</code> available from the
<code>SDLx::App</code> offers the use of event callbacks with which to
handle events. Processing events is a matter of setting up the appropriate
callbacks and letting SDL do the heavy work.</p>

<blockquote>

<p><b>SDL Events Types</b></p>

<p>Additional Event types that can be captured by SDL are:</p>

<ul>

<li>Keyboard

<p><code>SDL_KEYDOWN</code> <code>SDL_KEYUP</code> - Keyboard button
pressed</p>

<li>Mouse

<p><code>SDL_MOUSEMOTION</code> - Mouse motion occured</p>

<p><code>SDL_MOUSEBUTTONDOWN</code> <code>SDL_MOUSEBUTTONUP</code> - Mouse
button pressed</p>

<li>Joystick

<p><code>SDL_JOYAXISMOTION</code> - Joystick axis motion</p>

<p><code>SDL_JOYBALLMOTION</code> - Joystick trackball motion</p>

<p><code>SDL_JOYHATMOTION</code> - Joystick hat position change</p>

<p><code>SDL_JOYBUTTONDOWN</code> <code>SDL_JOYBUTTONUP</code> - Joystick
button pressed</p>

<li>Window & System

<p><code>SDL_ACTIVEEVENT</code> - Application visibility</p>

<p><code>SDL_VIDEORESIZE</code> - Window resized</p>

<p><code>SDL_VIDEOEXPOSE</code> - Window exposed</p>

<p><code>SDL_QUIT</code> - Quit requested</p>

<p><code>SDL_USEREVENT</code> - A user-defined event type</p>

<p><code>SDL_SYSWMEVENT</code> - Platform-dependent window manager
event</p>

</ul>

<p>For more information look at:</p>

<pre><code>        perldoc SDL::Event </code></pre>

</blockquote>

<h2>Quitting with Grace</h2>

<p>The example applications so far have not exited cleanly. Handling quit
events is much better:</p>

<pre><code>    use strict;
    use warnings;
    use SDL;
    use SDL::Event;
    use SDLx::App;

    my $app = SDLx::App-&gt;new(
        w     =&gt; 200,
        h     =&gt; 200,
        d     =&gt;  32,
        title =&gt; &quot;Quit Events&quot;
    );

    $app-&gt;add_event_handler( \&amp;quit_event );
    $app-&gt;run();

    sub quit_event
    {
        # the callback receives the appropriate SDL::Event
            my $event = shift;

            # ... as well as the calling SDLx::Controller
            my $controller = shift;

        # stopping the controller will exit $app-&gt;run() for us
            $controller-&gt;stop if $event-&gt;type == SDL_QUIT;
    }</code></pre>

<p><code>SDLx::App</code> calls the event_handlers, from an internal
<code>SDLx::Controller</code>. When this event handler receives a quit
event, it calls <code>SDLx::Controller::stop()</code> which causes
<code>SDLx::App</code> to exit gracefully.</p>

<h3>Exit on Quit</h3>

<p>Exiting on receiving the <code>SDL_QUIT</code> event is such a common
operation that <code>SDLx::App</code> provides it as a constructor
option:</p>

<pre><code>    use strict;
    use warnings;
    use SDL;
    use SDLx::App;

    my $app = SDLx::App-&gt;new(
        w            =&gt; 200,
        h            =&gt; 200,
        d            =&gt;  32,
        title        =&gt; &quot;Quit Events&quot;,
        exit_on_quit =&gt; 1
    );

    $app-&gt;run();</code></pre>

<h2>Small Paint: Input Devices</h2>

<p>SDL events also allow input handling. Consider a simple paint program.
It will provide a small black window. Moving the mouse draws on this
window. Pressing a number key chooses a paint color. Pressing
<code>q</code> or <code>Q</code> exits the program. Pressing <code>c</code>
or <code>C</code> clears the screen. Pressing <code>Ctrl-S</code> saves the
image to a file named <i>painted.bmp</i>.</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/painted.png}
\caption{Simple Paint: Smile} \label{fig:Smile}</p>



<h3>Saving the image</h3>

<p>Start by defining the saving function:</p>

<pre><code>    sub save_image {
        if (SDL::Video::save_BMP( $app, &#39;painted.bmp&#39; ) == 0
        &amp;&amp; -e &#39;painted.bmp&#39;)
        {
             warn &#39;Saved painted.bmp to &#39; . cwd();
        }
        else
        {
            warn &#39;Could not save painted.bmp: &#39; . SDL::get_errors();
        }
    }</code></pre>

<h3>Keyboard</h3>

<p>Keyboard handling requires some color data as well as a keypress
callback:</p>

<pre><code>    my $brush_color = 0;

    sub keyboard_event
    {
        my $event = shift;

        if ( $event-&gt;type == SDL_KEYDOWN )
        {
            # convert the key_symbol (integer) to a keyname
            my $key_name = SDL::Events::get_key_name( $event-&gt;key_sym );

            # if $key_name is a digit, use it as a color
            $brush_color = $key_name if $key_name =~ /^\d$/;

            # get the keyboard modifier (see perldoc SDL::Events)
            my $mod_state = SDL::Events::get_mod_state();

            # we are using any CTRL so KMOD_CTRL is fine
            save_image() if $key_name =~ /^s$/ &amp;&amp; ($mod_state &amp; KMOD_CTRL);

            # clear the screen
            $app-&gt;draw_rect( [ 0, 0, $app-&gt;w, $app-&gt;h ], 0 )
                if $key_name =~ /^c$/;

            # exit
            $app-&gt;stop() if $key_name =~ /^q$/;
        }

        $app-&gt;update();
    }

    $app-&gt;add_event_handler(\&amp;quit_event);
    $app-&gt;add_event_handler(\&amp;keyboard_event);</code></pre>

<blockquote>

<p><b>NOTE: </b> When adding a callback to <code>SDLx::App</code> which
uses variables declared outside of the function (<code>$brush_color</code>
and <code>@colors</code> in this case), be sure to define them before
declaring the subroutine. Normal Perl scoping and initialization rules
apply.</p>

</blockquote>

<h3>Mouse</h3>

<p>Handling mouse events is almost as straightforward as keyboard events:
=begin programlisting</p>

<pre><code>    # track the drawing status
    my $drawing = 0;

    sub mouse_event {
        my $event = shift;

        # detect Mouse Button events and check if user is currently drawing
        if ($event-&gt;type == SDL_MOUSEBUTTONDOWN || $drawing)
        {
            # set drawing to 1
            $drawing = 1;

            # get the X and Y values of the mouse
            my $x = $event-&gt;button_x;
            my $y = $event-&gt;button_y;

            # draw a rectangle at the specified position
            $app-&gt;draw_rect( [ $x, $y, 2, 2 ], $colors[$brush_color] );

            $app-&gt;update();
        }

        # disable drawing when user releases mouse button
        $drawing = 0 if ($event-&gt;type == SDL_MOUSEBUTTONUP );
    }

    $app-&gt;add_event_handler( \&amp;mouse_event );</code></pre>

<p>This is all of the code necessary to make a simple drawing
application.</p>

<p>Take note of two things. First, SDL_perl invokes the event handlers in
the order of attachment. If the user presses <code>Q</code> and then moves
the mouse, the application will quit before processing the mouse
movement.</p>

<p>Second, the application makes no distinction between right, middle, or
left mouse clicks. SDL provides this information. See the
<code>button_button()</code> method in <code>SDL::Event</code>.</p>

<h2>POD ERRORS</h2>

<p>Hey! <b>The above document had some coding errors, which are explained
below:</b></p>

<ul>

<li>Around line 317:

<p>=end programlisting without matching =begin.  (Stack: [empty])</p>

</ul>

<h1>The Game Loop</h1>

<p></p>

<p>Just as an interactive SDL app builds around an event loop, a game
builds around a game loop. The simplest game loop is something like:</p>

<pre><code>    while (!$quit)
    {
       get_events();
       calculate_next_positions();
       render();
    }</code></pre>

<p>The names of the functions called in this loop hint at their purposes,
but the subtleties of even this simple code are important.
<code>get_events()</code> obviously processes events from the relevant
input devices (keyboard, mouse, joystick). Processing events at the start
of every game loop iteration helps to prevent lag.</p>

<p><code>calculate_next_positions</code> updates the game state according
to user input as well as any active animations (a player walking, an
explosion, a cut scene). <code>render()</code> finally updates and displays
the screen.</p>

<h2>A Practical Game Loop</h2>

<p>Consider a game with a moving laser bolt:</p>

<pre><code>    use strict;
    use warnings;
    use SDL;
    use SDL::Event;
    use SDL::Events;
    use SDLx::App;

    my $app = SDLx::App-&gt;new(
        width  =&gt; 200,
        height =&gt; 200,
        title  =&gt; &#39;Pew Pew&#39;
    );

    my $quit = 0;

    # start laser on the left
    my $laser = 0;

    sub get_events {
        my $event = SDL::Event-&gt;new();

        SDL::Events::pump_events;

        while( SDL::Events::poll_event($event) )
        {
            $quit = 1 if $event-&gt;type == SDL_QUIT
        }
    }

    sub calculate_next_positions {
            # move the laser
        $laser++;

            # if the laser goes off the screen, bring it back
        $laser = 0 if $laser &gt; $app-&gt;w();
    }

    sub render {
        # draw the background first
        $app-&gt;draw_rect( [ 0, 0, $app-&gt;w, $app-&gt;h ], 0 );

        # draw the laser halfway up the screen
        $app-&gt;draw_rect( [ $laser, $app-&gt;h / 2, 10, 2 ], [ 255, 0, 0, 255 ]);

        $app-&gt;update();
    }

    while (!$quit)
    {
         get_events();
         calculate_next_positions();
         render();
    }</code></pre>

<p>This game loop works very well for consoles and other devices where you
know exactly how much CPU time the game will get for every loop iteration.
That hardware stability is easy to predict: each animation and calculation
will happen at the same time for each machine. Unfortunately, this is
<i>not</i> true for modern operating systems and general purpose computing
hardware. CPU speeds and workloads vary, so for this game to play
consistently across multiple machines and myriad configurations, the game
loop itself needs to regulate its updates.</p>

<h3>Fixed FPS</h3>

<p> </p>

<p>One way to solve this problem is to regulate the number of frames per
second the game will produce. A <i>frame</i> is a complete redraw of the
screen representing the updated game state. If each iteration of the game
loop draws one frame, the more frames per second, the faster the game is
running. If the game loop limits the number of frames per second, the game
will perform consistently on all machines fast enough to draw that many
frames per second.</p>

<p>You can see this with the example program <i>game_fixed.pl</i>. When run
with no arguments:</p>

<pre><code>    $ <b>perl game_fixed.pl</b></code></pre>

<p>.... the FPS rate will be erratic. The laser seems to change its speed
randomly. When run with a single argument, the game sets an upper bound on
the number of frames per second:</p>

<pre><code>    $ <b>perl game_fixed.pl 1</b></code></pre>

<p>This will prevent the laser from going faster than 60 frames per second.
When run with a second argument, the game will set a lower bound of frames
per second:</p>

<pre><code>    $ <b>perl game_fixed.pl 1 1</b></code></pre>

<p>At this point the FPS should hold steady at 60 frames per second.</p>

<pre><code>        use strict;
        use warnings;
        use SDL;
        use SDL::Event;
        use SDL::Events;
        use SDLx::App;

        my $app = SDLx::App-&gt;new(
                        width  =&gt; 200,
                        height =&gt; 200,
                        title  =&gt; &#39;Pew Pew&#39;
        );

        my ( $start, $end, $delta_time, $FPS, $frames ) = ( 0, 0, 0, 0, 0 );

        # aim for a rate of 60 frames per second
        my $fixed_rate = 60;

        # compensate for times stored in microseconds
        my $fps_check = (1000 / $fixed_rate );

        my $quit = 0;

        # start laser on the left
        my $laser = 0;

        sub get_events {
                my $event = SDL::Event-&gt;new();

                SDL::Events::pump_events;

                while ( SDL::Events::poll_event($event) ) {
                        $quit = 1 if $event-&gt;type == SDL_QUIT;
                }
        }

        sub calculate_next_positions {
                $laser++;

                $laser = 0 if $laser &gt; $app-&gt;w;
        }

        sub render {
                # draw the background first
                $app-&gt;draw_rect( [ 0, 0, $app-&gt;w, $app-&gt;h ], 0 );

                # draw the laser
                $app-&gt;draw_rect( [ $laser, $app-&gt;h / 2, 10, 2 ], [ 255, 0, 0, 255 ] );

                # draw the FPS
                $app-&gt;draw_gfx_text( [ 10, 10 ], [ 255, 0, 255, 255 ], &quot;FPS: $FPS&quot; );

                $app-&gt;update();
        }

        # Called at the end of each frame, whether we draw or not
        sub calculate_fps_at_frame_end
        {
                # Ticks are microseconds since load time
                $end = SDL::get_ticks();

        # smooth the frame rate by averaging over 10 frames
                if ( $frames &lt; 10 ) {
                        $frames++;
                        $delta_time += $end - $start;
                }
                else {
                        # frame rate is Frames * 100 / Time Elapsed in us
            $FPS        = int( ( $frames * 100 ) / $delta_time )
                        if $delta_time != 0;

                        # reset metrics
                        $frames     = 0;
                        $delta_time = 0;
                }
        }

        while ( !$quit ) {
                # Get the time for the starting of the frame
                $start = SDL::get_ticks();

                get_events();

                # if fixing the lower bounds of the frame rate
                if( $ARGV[1] )
                {
                        # if delta time is going too slow for frame check
                        if ( $delta_time &gt; $fps_check ) {

                                calculate_fps_at_frame_end();

                # skip rendering and collision detections
                # (heavy functions in the game loop)
                                next;           
                        }
                }

                calculate_next_positions();
                render();

                # a normal frame with rendering actually performed
                calculate_fps_at_frame_end();

                # if fixing the upper bounds of the frame rate
                if ( $ARGV[0] ) {
                        
                        # if delta time is going too fast compared to the frame check
                        if ( $delta_time &lt; $fps_check ) {

                                # delay for the difference
                                SDL::delay( $fps_check - $delta_time );
                        }
                }
        }</code></pre>

<p>This method is generally sufficient for most computers. The animations
will be smooth enough to provide the same gameplay even on machines with
different hardware.</p>

<p>However, this method still has some serious problems. First, if a
computer is too slow to sustain a rate of 60 FPS, the game will skip
rendering some frames, leading to sparse and jittery animation.it will skip
a lot of rendering, and the animation will look sparse and jittery. It
might be better to set a lower bounds of 30 FPS, though it's difficult to
predict the best frame rate for a user.</p>

<p>The worst problem is that this technique still ties rendering speed to
the CPU speed: a very fast computer will waste CPU cycles delaying.</p>

<h3>Variable FPS</h3>

<p>To fix the problem of a computer being consistently too fast or too slow
for the hard-coded FPS rate is to adjust the FPS rate accordingly. A slow
CPU may limit itself to 30 FPS, while a fast CPU might run at 300 FPS.
Although you may achieve a consistent rate this way (consistent for any one
particular computer), this technique still presents the problem of
differing animation speeds between different computers.</p>

<p>Better solutions are available.</p>

<h2>Integrating Physics</h2>

<p>Describe movement and show handlers.</p>

<p>The problem caused by coupling rendering to the CPU speed has a
convenient solution. Instead of updating object positions based on how fast
the computer can get through the game loop, derive their positions from a
physical model based on the passage of time. Objects moving according to
real world time will have consistent behavior at all CPU speeds and smooth
interpolation between frames. <code>SDLx::App</code> provides this behavior
through movement and show handlers.</p>

<p>Consider a simple physics model for the laser has a consistent
horizontal velocity in pixels per time step at the window's mid-point:</p>

<pre><code>    X = Velocity * time step,
    Y = 100</code></pre>

<p>Assuming a velocity of 10, the laser will pass through the
coordinates:</p>

<pre><code>      0, 100
     10, 100
     20, 100
     30, 100
    ...
    200, 100</code></pre>

<p>Note that the speed of processing the game loop no longer matters. The
position of the laser depends instead on the passage of real time.</p>

<p>The biggest problem with this approach is the required bookkeeping for
the many objects and callbacks. The implementation of such complex models
is non-trivial; see the lengthy discussion in the documentation of the
<code>SDLx::Controller</code> module.</p>

<p><code>SDLx::App</code> using the <code>SDLx::Controller</code> module
provide callbacks to handle both aspects of this type of game loop. One is
the the movement handler, which is a callback where calculations of the
next step for each relevant data point is calculated. In the above example
the movement handler would calculate the <code>X</code> and <code>Y</code>
values, for each time step between the frames of animations.</p>

<p>When we are ready to render the frame it is handled by the show handler.
In the above example that would mean the show handler would print or render
the <code>X, Y</code> values.</p>

<h3>Laser in Real Time</h3>

<p>This version of the laser example demonstrates the use of movement, show
handlers, and a simple physics model. This example also shows how
<code>SDLx::App</code> can do more of the work, even providing the entire
game loop:</p>

<pre><code>        use strict;
        use warnings;
        use SDL;
        use SDL::Event;
        use SDLx::App;

        my $app = SDLx::App-&gt;new(
            width  =&gt; 200,
            height =&gt; 200,
            title  =&gt; &#39;Pew Pew&#39;
        );

        my $laser    = 0;
        my $velocity = 10;

        $app-&gt;add_event_handler( \&amp;quit_event );

        # tell app to handle the appropriate times to
        # call both rendering and physics calculation

        $app-&gt;add_move_handler( \&amp;calculate_laser );
        $app-&gt;add_show_handler( \&amp;render_laser );

        $app-&gt;run();

        sub quit_event {
            my $event      = shift;
            my $controller = shift;

            $controller-&gt;stop if $event-&gt;type == SDL_QUIT;
        }

        sub calculate_laser {

            # The step is the difference in Time calculated for the next jump
            my ( $step, $app, $t ) = @_;
            $laser += $velocity * $step;
            $laser = 0 if $laser &gt; $app-&gt;w;
        }

        sub render_laser {
            my ( $delta, $app ) = @_;

            # The delta can be used to render blurred frames

            # draw the background first
            $app-&gt;draw_rect( [ 0, 0, $app-&gt;w, $app-&gt;h ], 0 );

            # draw the laser
            $app-&gt;draw_rect( [ $laser, $app-&gt;h / 2, 10, 2 ], [ 255, 0, 0, 255 ] );
            $app-&gt;update();
        }</code></pre>

<p>To learn more about this topic please, see an excellent blog post by
<b>GafferOnGames.com</b>:
HTTP://GafferOnGames.Com/game-physics/fix-your-timestep.</p>

<h1>Pong!</h1>

<h2>The Game</h2>

<p>Pong is one of the first popular video games in the world. It was
created by Allan Alcorn for Atari Inc. and released in 1972, being Atari's
first game ever, and sparkling the beginning of the video game
industry.</p>

<p>Pong simulates a table tennis match ("ping pong"), where you try to
defeat your opponent by earning a higher score. Each player controls a
paddle moving it vertically on the screen, and use it to hit a bouncing
ball back and forth. You earn a point if your opponent is unable to return
the ball to your side of the screen.</p>

<p>And now we're gonna learn how to create one ourselves in Perl and
SDL.</p>

<h3>Getting our feet wet</h3>

<p>Let's start by making a simple screen for our Pong clone. Open a file in
your favourite text editor and type:</p>

<pre><code>    + #!/usr/bin/perl
    + use strict;
    + use warnings;
    + 
    + use SDL;
    + use SDLx::App;
    + 
    + # create our main screen
    + my $app = SDLx::App-&gt;new(
    +     width        =&gt; 500,
    +     height       =&gt; 500,
    +     title        =&gt; &#39;My Pong Clone!&#39;,
    +     dt           =&gt; 0.02,
    +     exit_on_quit =&gt; 1,
    + );
    + 
    + # let&#39;s roll!
    + $app-&gt;run;</code></pre>

<p>Save this file as <code>"pong.pl"</code> and run it by typing on the
command line:</p>

<pre><code>  perl pong.pl</code></pre>

<p>You should see a 500x500 black window entitled <i>"My Pong Clone!"</i>.
In our SDLx::App construction we also set a time interval (dt) of 0.02 for
the game loop, and let it handle SDL_QUIT events for us. If any of the
arguments above came as a surprise to you, please refer to previous
chapters for an in-depth explanation.</p>

<h3>Game Objects</h3>

<p>There are three main game objects in Pong: the player's paddle, the
enemy's paddle, and a bouncing ball.</p>

<p>Paddles are rectangles moving vertically on the screen, and can be
easily represented with SDLx::Rect objects. First, put
<code>SDLx::Rect</code> in your module's declarations:</p>

<pre><code>      use SDL;
      use SDLx::App;
    + use SDLx::Rect;</code></pre>

<p>Now let's add a simple hash reference in our code to store our player's
paddle, between the call to <code>SDLx::App->new()</code> and
<code>$app->run</code>.</p>

<p>We'll use a hash reference instead of just assigning a
<code>SDLx::Rect</code> to a variable because it will allow us to store
more information later on. If you were building a more complex game, you
should consider using actual objects. For now, a simple hash reference will
suffice:</p>

<pre><code>    + my $player1 = {
    +      paddle =&gt; SDLx::Rect-&gt;new( 10, $app-&gt;h / 2, 10, 40),
    + };</code></pre>

<p>As we know, <code>SDLx::Rect</code> objects receive four arguments: x,
y, width and height, in this order. So in the code above we're creating a
10x40 paddle rect for player 1, on the left side of the screen (<code>x =
10</code>) and somewhat in the center (<code>y = $app->h / 2</code>).</p>

<p>Let's do the same for player 2, adding the following code right after
the one above:</p>

<pre><code>    + my $player2 = {
    +      paddle =&gt; SDLx::Rect-&gt;new( $app-&gt;w - 20, $app-&gt;h / 2, 10, 40),
    + };</code></pre>

<p>Player 2's paddle, also 10x40, needs to go to the right end of the
screen. So we make its <code>x</code> position as our screen's width minus
20. Since the paddle has a width of 10 itself and the <code>x</code>
position refers to the rect's top-left corner, it will leave a space of 10
pixels between its rightmost side and the end of the screen, just like we
did for player 1.</p>

<p>Finally, the bouncing ball, a 10x10 rect in the middle of the
screen:</p>

<pre><code>    + my $ball = {
    +     rect =&gt; SDLx::Rect-&gt;new( $app-&gt;w / 2, $app-&gt;h / 2, 10, 10 ),
    + };</code></pre>

<p>Yes, it's a "square ball", just like the original :)</p>

<h4>Show me what you got!</h4>

<p>Now that we created our game objects, let's add a 'show' handler to
render them on the screen:</p>

<pre><code>    + $app-&gt;add_show_handler(
    +     sub {
    +         # first, we clear the screen
    +         $app-&gt;draw_rect( [0, 0, $app-&gt;w, $app-&gt;h], 0x000000FF );
    + 
    +         # then we render the ball
    +         $app-&gt;draw_rect( $ball-&gt;{rect}, 0xFF0000FF );
    + 
    +         # ... and each paddle
    +         $app-&gt;draw_rect( $player1-&gt;{paddle}, 0xFF0000FF );
    +         $app-&gt;draw_rect( $player2-&gt;{paddle}, 0xFF0000FF );
    + 
    +         # finally, we update the screen
    +         $app-&gt;update;
    +     }
    + );</code></pre>

<p>Our approach is rather simple here, "clearing" the screen by painting a
black rectangle the size of the screen, then using <code>draw_rect()</code>
calls to paint opaque red (<code>0xFF0000FF</code>) rectangles in each
object's position.</p>

<p>The result can be seen on the screenshot below:</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/pong1.png}
\caption{First view of our Pong clone} \label{fig:pong1}</p>



<h3>Moving the Player's Paddle</h3>

<p>It's time to let the player move the left paddle! Take a few moments to
recap what motion is all about: changing your object's position with
respect to time. If it's some sort of magical teleportation repositioning,
just change the (x,y) coordinates and be done with it. If however, we're
talking about real motion, we need to move at a certain speed. Our paddle
will have constant speed, so we don't need to worry about acceleration.
Also, since it will only move vertically, we just need to add the vertical
(y) velocity. Let's call it <code>v_y</code> and add it to our paddle
structure:</p>

<pre><code>      my $player1 = {
           paddle =&gt; SDLx::Rect-&gt;new( 10, $app-&gt;h / 2, 10, 40),
    +      v_y    =&gt; 0,
      };</code></pre>

<p>Ok, now we have an attribute for vertical velocity (<code>v_y</code>) in
our paddle, so what? How will this update the <code>y</code> position of
the paddle? Well, velocity is how much displacement happens in a unit of
time, like 20 km/h or 4 m/s. In our case, the unit of time is the app's
<code>dt</code>, so all we have to do is move the paddle <code>v_y</code>
pixels per <code>dt</code>. Here is where the motion handlers come in
handy:</p>

<pre><code>    + # handles the player&#39;s paddle movement
    + $app-&gt;add_move_handler( sub {
    +     my ( $step, $app ) = @_;
    +     my $paddle = $player1-&gt;{paddle};
    +     my $v_y = $player1-&gt;{v_y};
    + 
    +     $paddle-&gt;y( $paddle-&gt;y + ( $v_y * $step ) );
    + });</code></pre>

<p>If you recall previous chapters, the code above should be pretty
straightforward. When <code>v_y</code> is 0 at any given run cycle, the
paddle won't change its <code>y</code> position. If, however, there is a
vertical velocity, we update the <code>y</code> position based on how much
of the expected cycle time (our app's "dt") has passed. A value of 1 in
<code>$step</code> indicates a full cycle went through, and makes
<code>$v_y * $step</code> the same as <code>$v_y * 1</code>, thus, plain
<code>$v_y</code> - which is the desired speed for our cycle. Should the
handler be called in a shorter cycle, we'll move only the relative factor
of that.</p>

<h4>Player 2? Rinse and repeat</h4>

<p>We're not going to worry at this point about moving your nemesis'
paddle, but since it uses the same motion mechanics of our player's, it
won't hurt to prepare it:</p>

<pre><code>      my $player2 = {
           paddle =&gt; SDLx::Rect-&gt;new( $app-&gt;w - 20, $app-&gt;h / 2, 10, 40),
    +      v_y    =&gt; 0,
      };</code></pre>

<p>And add a simple motion handler, just like our player's:</p>

<pre><code>    + # handles AI&#39;s paddle movement
    + $app-&gt;add_move_handler( sub {
    +     my ( $step, $app ) = @_;
    +     my $paddle = $player2-&gt;{paddle};
    +     my $v_y = $player2-&gt;{v_y};
    +
    +     $paddle-&gt;y( $paddle-&gt;y + ( $v_y * $step ) );
    + });</code></pre>

<h4>Back to our Player: Move that Paddle!</h4>

<p>We have preset <code>v_y</code> to zero as the paddle's initial
velocity, so our player's paddle won't go haywire when the game starts. But
we still need to know when the user wants to move it up or down the screen.
In order to do that, we can bind the up and down arrow keys of the keyboard
to positive and negative velocities for our paddle, through an event hook.
Since we're going to use some event constants like <code>SDLK_DOWN</code>,
we need to load the SDL::Events module:</p>

<pre><code>     use SDL;
   + use SDL::Events;
     use SDLx::App;
     use SDLx::Rect;</code></pre>

<p>Then we can proceed to create our event hook:</p>

<pre><code>   + # handles keyboard events
   + $app-&gt;add_event_handler(
   +     sub {
   +         my ( $event, $app ) = @_;
   +
   +         # user pressing a key
   +         if ( $event-&gt;type == SDL_KEYDOWN ) {
   +
   +             # up arrow key means going up (negative vel)
   +             if ( $event-&gt;key_sym == SDLK_UP ) {
   +                 $player1-&gt;{v_y} = -2;
   +             }
   +             # down arrow key means going down (positive vel)
   +             elsif ( $event-&gt;key_sym == SDLK_DOWN ) {
   +                 $player1-&gt;{v_y} = 2;
   +             }
   +         }
   +         # user releasing a key
   +         elsif ( $event-&gt;type == SDL_KEYUP ) {
   +
   +             # up or down arrow keys released, stop the paddle
   +             if (
   +                     $event-&gt;key_sym == SDLK_UP
   +                  or $event-&gt;key_sym == SDLK_DOWN
   +             ) {
   +                 $player1-&gt;{v_y} = 0;
   +             }
   +         }
   +     }
   + );</code></pre>

<p>Again, nothing new here. Whenever the user presses the up arrow key, we
want the paddle to go up. Keep in mind our origin point (0,0) in SDL is the
top-left corner, so a negative <code>v_y</code> will decrease the paddle's
<code>y</code> and send it <b>up</b> the screen. Alternatively, we add a
positive value to <code>v_y</code> whenever the user presses the down arrow
key, so the paddle will move <b>down</b>, away from the top of the screen.
When the user releases either the up or down arrow keys, we stop the paddle
by setting <code>v_y</code> to 0.</p>

<h3>A Bouncing Ball</h3>

<p>How about we animate the game ball? The movement itself is pretty
similar to our paddle's, except the ball will also have a horizontal
velocity ("<code>v_x</code>") component, letting it move all over the
screen.</p>

<p>First, we add the velocity components to our ball structure:</p>

<pre><code>     my $ball = {
         rect =&gt; SDLx::Rect-&gt;new( $app-&gt;w / 2, $app-&gt;h / 2, 10, 10 ),
   +     v_x  =&gt; -2.7,
   +     v_y  =&gt; 1.8,
     };</code></pre>

<p>The ball will have an initial velocity of -2.7 horizontally (just as a
negative vertical velocity moves the object up, a negative horizontal
velocity will move it towards the left side of the screen), and 1.8
vertically. Next, we create a motion handler for the ball, updating the
ball's <code>x</code> and <code>y</code> position according to its
speed:</p>

<pre><code>   + # handles the ball movement
   + $app-&gt;add_move_handler( sub {
   +     my ( $step, $app ) = @_;
   +     my $ball_rect = $ball-&gt;{rect};
   +
   +     $ball_rect-&gt;x( $ball_rect-&gt;x + ($ball-&gt;{v_x} * $step) );
   +     $ball_rect-&gt;y( $ball_rect-&gt;y + ($ball-&gt;{v_y} * $step) );
   + });</code></pre>

<p>This is just like our paddle's motion handler: we update the ball's
<code>x</code> and <code>y</code> position on the screen according to the
current velocity. If you are paying attention, however, you probably
realized the code above is missing a very important piece of logic. Need a
clue? Try running the game as it is. You'll see the ball going, going,
and... gone!</p>

<p>We need to make sure the ball is bound to the screen. That is, it needs
to collide and bounce back whenever it reaches the top and bottom edges of
the screen. So let's change our ball's motion handler a bit, adding this
functionality:</p>

<pre><code>     # handles the ball movement
     $app-&gt;add_move_handler( sub {
         my ( $step, $app ) = @_;
         my $ball_rect = $ball-&gt;{rect};
    
         $ball_rect-&gt;x( $ball_rect-&gt;x + ($ball-&gt;{v_x} * $step) );
         $ball_rect-&gt;y( $ball_rect-&gt;y + ($ball-&gt;{v_y} * $step) );
 
   +     # collision to the bottom of the screen
   +     if ( $ball_rect-&gt;bottom &gt;= $app-&gt;h ) {
   +         $ball_rect-&gt;bottom( $app-&gt;h );
   +         $ball-&gt;{v_y} *= -1;
   +     }
   +
   +     # collision to the top of the screen
   +     elsif ( $ball_rect-&gt;top &lt;= 0 ) {
   +         $ball_rect-&gt;top( 0 );
   +         $ball-&gt;{v_y} *= -1;
   +     }
     });</code></pre>

<p>If the new y (<code>"bottom"</code> or <code>"top"</code>) value would
take the ball totally or partially off the screen, we replace it with the
farthest position possible (making it "touch" that edge of the screen) and
reverse <code>v_y</code>, so it will go the opposite way on the next cycle,
bouncing back into the screen.</p>

<h4>He shoots... and scores!!</h4>

<p>So far, so good. But what should happen when the ball hits the left or
right edges of the screen? Well, according to the rules of Pong, this means
the player on the opposite side scored a point, and the ball should go back
to the center of the screen. Let's begin by adding a 'score' attribute for
each player:</p>

<pre><code>      my $player1 = {
           paddle =&gt; SDLx::Rect-&gt;new( 10, $app-&gt;h / 2, 10, 40),
           v_y    =&gt; 0,
    +      score  =&gt; 0,
      };

      my $player2 = {
           paddle =&gt; SDLx::Rect-&gt;new( $app-&gt;w - 20, $app-&gt;h / 2, 10, 40),
           v_y    =&gt; 0,
    +      score  =&gt; 0,
      };</code></pre>

<p>Now we should teach the ball's motion handler what to do when it reaches
the left and right corners:</p>

<pre><code>     # handles the ball movement
     $app-&gt;add_move_handler( sub {
         my ( $step, $app ) = @_;
         my $ball_rect = $ball-&gt;{rect};
    
         $ball_rect-&gt;x( $ball_rect-&gt;x + ($ball-&gt;{v_x} * $step) );
         $ball_rect-&gt;y( $ball_rect-&gt;y + ($ball-&gt;{v_y} * $step) );
 
         # collision to the bottom of the screen
         if ( $ball_rect-&gt;bottom &gt;= $app-&gt;h ) {
             $ball_rect-&gt;bottom( $app-&gt;h );
             $ball-&gt;{v_y} *= -1;
         }
    
         # collision to the top of the screen
         elsif ( $ball_rect-&gt;top &lt;= 0 ) {
             $ball_rect-&gt;top( 0 );
             $ball-&gt;{v_y} *= -1;
         }
   
   +     # collision to the right: player 1 score!
   +     elsif ( $ball_rect-&gt;right &gt;= $app-&gt;w ) {
   +         $player1-&gt;{score}++;
   +         reset_game();
   +         return;
   +     }
   +
   +     # collision to the left: player 2 score!
   +     elsif ( $ball_rect-&gt;left &lt;= 0 ) {
   +         $player2-&gt;{score}++;
   +         reset_game();
   +         return;
   +     }
     });</code></pre>

<p>If the ball's right hits the right end of the screen (the app's width),
we increase player 1's score, call <code>reset_game()</code>, and return
without updating the ball's position. If the ball's left hits the left end
of the screen, we do the same for player 2.</p>

<p>We want the <code>reset_game()</code> function called above to set the
ball back on the center of the screen, so let's make it happen:</p>

<pre><code>   + sub reset_game {
   +     $ball-&gt;{rect}-&gt;x( $app-&gt;w / 2 );
   +     $ball-&gt;{rect}-&gt;y( $app-&gt;h / 2 );
   + }</code></pre>

<h3>Collision Detection: The Ball and The Paddle</h3>

<p>We already learned how to do some simple collision detection, namely
between the ball and the edges of the screen. Now it's time to take it one
step further and figure out how to check whether the ball and the paddles
are overlapping one another (colliding, or rather, intersecting). This is
done via the Separating Axis Theorem, which roughly states that two convex
shapes in a 2D plane are <b>not</b> intersecting if and only if we can
place a line separating them. Since our rect objects (the ball and paddles)
are both axis-aligned, we can simply pick one, and there will be only 4
possible lines to test: its left, right, top and bottom. If the other
object is completely on one side of any of those lines, then there is
<b>no</b> collision. But if all four conditions are false, they are
intersecting.</p>

<p>To put it in more general terms, if we have 2 rects, A and B, we can
establish the following conditions, illustrated by the figure below:</p>

<p>\includegraphics[width=0.9\textwidth]{../src/images/collision.png}
\caption{if B is completely to the left, right, top or bottom of A, they do
NOT intersect} \label{fig:pong1}</p>



<ul>

<li>if A's bottom side is above B's top side, then A is completely above B
(fig. 6.2.1).</li>

<li>if A's top side is below B's bottom side, then A is completely below B
(fig. 6.2.2).</li>

<li>if A's right side is to the left of B's left side, then A is completely
to the left of B (fig. 6.2.3).</li>

<li>if A's left side is to the right of B's right side, then A is
completely to the right of B (fig 6.2.4).</li>

</ul>

<p>Keeping in mind that our origin point (0,0) in SDL is the top-left
corner, we can translate the rules above to the following generic
<code>check_collision()</code> function, receiving two rect objects and
returning true if they collide:</p>

<pre><code>   + sub check_collision {
   +     my ($A, $B) = @_;
   +
   +     return if $A-&gt;bottom &lt; $B-&gt;top;
   +     return if $A-&gt;top    &gt; $B-&gt;bottom;
   +     return if $A-&gt;right  &lt; $B-&gt;left;
   +     return if $A-&gt;left   &gt; $B-&gt;right;
   +
   +     # if we got here, we have a collision!
   +     return 1;
   + }</code></pre>

<p>We can now use it in the ball's motion handler to see if it hits any of
the paddles:</p>

<pre><code>     # handles the ball movement
     $app-&gt;add_move_handler( sub {
         my ( $step, $app ) = @_;
         my $ball_rect = $ball-&gt;{rect};
    
         $ball_rect-&gt;x( $ball_rect-&gt;x + ($ball-&gt;{v_x} * $step) );
         $ball_rect-&gt;y( $ball_rect-&gt;y + ($ball-&gt;{v_y} * $step) );
 
         # collision to the bottom of the screen
         if ( $ball_rect-&gt;bottom &gt;= $app-&gt;h ) {
             $ball_rect-&gt;bottom( $app-&gt;h );
             $ball-&gt;{v_y} *= -1;
         }
    
         # collision to the top of the screen
         elsif ( $ball_rect-&gt;top &lt;= 0 ) {
             $ball_rect-&gt;top( 0 );
             $ball-&gt;{v_y} *= -1;
         }
   
         # collision to the right: player 1 score!
         elsif ( $ball_rect-&gt;right &gt;= $app-&gt;w ) {
             $player1-&gt;{score}++;
             reset_game();
             return;
         }
    
         # collision to the left: player 2 score!
         elsif ( $ball_rect-&gt;left &lt;= 0 ) {
             $player2-&gt;{score}++;
             reset_game();
             return;
         }

   +     # collision with player1&#39;s paddle
   +     elsif ( check_collision( $ball_rect, $player1-&gt;{paddle} )) {
   +         $ball_rect-&gt;left( $player1-&gt;{paddle}-&gt;right );
   +         $ball-&gt;{v_x} *= -1;
   +     }
   +
   +     # collision with player2&#39;s paddle
   +     elsif ( check_collision( $ball_rect, $player2-&gt;{paddle} )) {
   +         $ball-&gt;{v_x} *= -1;
   +         $ball_rect-&gt;right( $player2-&gt;{paddle}-&gt;left );
   +     }
     });</code></pre>

<p>That's it! If the ball hits player1's paddle, we reverse its horizontal
velocity (<code>v_x</code>) to make it bounce back, and set its left edge
to the paddle's right so they don't overlap. Then we do the exact same
thing for the other player's paddle, except this time we set the ball's
right to the paddle's left - since the ball is coming from the other
side.</p>

<h3>Artificial Stupidity</h3>

<p>Our Pong game is almost done now. We record the score, the ball bounces
around, we keep track of each player's score, and we can move the left
paddle with the up and down arrow keys. But this will be a very dull game
unless our nemesis moves too!</p>

<p>There are several complex algorithms to model artificial intelligence,
but we don't have to go that far for a simple game like this. What we're
going to do is make player2's paddle follow the ball wherever it goes, by
adding the following to its motion handler:</p>

<pre><code>      # handles AI&#39;s paddle movement
      $app-&gt;add_move_handler( sub {
          my ( $step, $app ) = @_;
          my $paddle = $player2-&gt;{paddle};
          my $v_y = $player2-&gt;{v_y};

    +     if ( $ball-&gt;{rect}-&gt;y &gt; $paddle-&gt;y ) {
    +         $player2-&gt;{v_y} = 1.5;
    +     }
    +     elsif ( $ball-&gt;{rect}-&gt;y &lt; $paddle-&gt;y ) {
    +         $player2-&gt;{v_y} = -1.5;
    +     }
    +     else {
    +         $player2-&gt;{v_y} = 0;
    +     }

          $paddle-&gt;y( $paddle-&gt;y + ( $v_y * $step ) );
      });</code></pre>

<p>If the ball's "<code>y</code>" value (its top) is greater than the
nemesis' paddle, it means the ball is below it, so we give the paddle a
positive velocity, making it go downwards. On the other hand, if the ball
has a lower "<code>y</code>" value, we set the nemesis' <code>v_y</code> to
a negative value, making it go up. Finally, if the ball is somewhere in
between those two values, we keep the paddle still.</p>

<h3>Cosmetics: Displaying the Score</h3>

<p>How about we display the score so the player can see who's winning? To
render a text string in SDL, we're going to use the SDLx::Text module, so
let's add it to the beginning of our code:</p>

<pre><code>     use SDL;
     use SDL::Events;
     use SDLx::App;
     use SDLx::Rect;
   + use SDLx::Text;</code></pre>

<p>Now we need to create the score object:</p>

<pre><code>   + my $score = SDLx::Text-&gt;new( font =&gt; &#39;font.ttf&#39;, h_align =&gt; &#39;center&#39; );</code></pre>

<p>The optional <code>font</code> parameter specifies the path to a
TrueType Font. Here we are loading the '<i>font.ttf</i>' file, so feel free
to change this to whatever font you have in your system. Otherwise, you can
leave it out and use the bundled default font. The <code>h_align</code>
parameter lets us choose a horizontal alignment for the text we put in the
object. It defaults to '<i>left</i>', so we make it '<i>center</i>'
instead.</p>

<p>All that's left is using this object to write the score on the screen,
so we update our 'show' handler:</p>

<pre><code>      $app-&gt;add_show_handler(
          sub {
              # first, we clear the screen
              $app-&gt;draw_rect( [0, 0, $app-&gt;w, $app-&gt;h], 0x000000FF );
      
              # then we render the ball
              $app-&gt;draw_rect( $ball-&gt;{rect}, 0xFF0000FF );
      
              # ... and each paddle
              $app-&gt;draw_rect( $player1-&gt;{paddle}, 0xFF0000FF );
              $app-&gt;draw_rect( $player2-&gt;{paddle}, 0xFF0000FF );
      
    +         # ... and each player&#39;s score!
    +         $score-&gt;write_to(
    +             $app,
    +             $player1-&gt;{score} . &#39; x &#39; . $player2-&gt;{score}
    +         );

              # finally, we update the screen
              $app-&gt;update;
          }
      );</code></pre>

<p>The <code>write_to()</code> call will write to any surface passed as the
first argument - in our case, the app itself. The second argument, as you
probably figured, is the string to be rendered. Note that the string's
position is relative to the surface it writes to, and defaults to (0,0).
Since we told it to center horizontally, it will write our text to the
top/center, instead of top/left.</p>

<p>The result, and our finished game, can be seen on the figure below:</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/pong2.png}
\caption{our finished Pong clone, in all its glory} \label{fig:pong2}</p>



<h3>Exercises</h3>

<ul>

<li>1. Every time a player scores, the ball goes back to the middle but has
the same sense and direction as before. See if you can make it restart at a
random direction instead.

<li>2. Red is boring, you want to make a completely psychedelic Pong! Pick
3 different colours and make each paddle oscillate between them every time
the ball hits it.

</ul>

<p>See if you can solve the exercises above by yourself, to make sure you
understand what is what and how to do things in SDL Perl. Once you're done,
check out the answers below. Of course, there's always more than one way to
do things, so the ones below are not the only possible answers.</p>

<h4>Answers</h4>

<p>1. To make the ball restart at a random direction, we can improve our
<code>reset_game()</code> function to set the ball's <code>v_x</code> and
<code>v_y</code> to a random value between, say, 1.5 and 2.5, or -1.5 and
-2.5:</p>

<pre><code>     sub reset_game {
         $ball-&gt;{rect}-&gt;x( $app-&gt;w / 2 );
         $ball-&gt;{rect}-&gt;y( $app-&gt;h / 2 );

   +     $ball-&gt;{v_x} = (1.5 + int rand 1) * (rand 2 &gt; 1 ? 1 : -1);
   +     $ball-&gt;{v_y} = (1.5 + int rand 1) * (rand 2 &gt; 1 ? 1 : -1);
     }</code></pre>

<p>2. We can either choose one colour set for both paddles or one for each.
Let's go with just one set, as an array of hex values representing our
colours. We'll also hold the index for the current colour for each
player:</p>

<pre><code>    + my @colours = qw( 0xFF0000FF 0x00FF00FF 0x0000FFFF 0xFFFF00FF );

      my $player1 = {
           paddle =&gt; SDLx::Rect-&gt;new( 10, $app-&gt;h / 2, 10, 40),
           v_y    =&gt; 0,
           score  =&gt; 0,
    +      colour =&gt; 0,
      };

      my $player2 = {
           paddle =&gt; SDLx::Rect-&gt;new( $app-&gt;w - 20, $app-&gt;h / 2, 10, 40),
           v_y    =&gt; 0,
           score  =&gt; 0,
    +      colour =&gt; 0,
      };</code></pre>

<p>Next we make it update the <code>colour</code> every time the ball hits
the paddle:</p>

<pre><code>     # handles the ball movement
     $app-&gt;add_move_handler( sub {
         my ( $step, $app ) = @_;
         my $ball_rect = $ball-&gt;{rect};
    
         $ball_rect-&gt;x( $ball_rect-&gt;x + ($ball-&gt;{v_x} * $step) );
         $ball_rect-&gt;y( $ball_rect-&gt;y + ($ball-&gt;{v_y} * $step) );
 
         # collision to the bottom of the screen
         if ( $ball_rect-&gt;bottom &gt;= $app-&gt;h ) {
             $ball_rect-&gt;bottom( $app-&gt;h );
             $ball-&gt;{v_y} *= -1;
         }
    
         # collision to the top of the screen
         elsif ( $ball_rect-&gt;top &lt;= 0 ) {
             $ball_rect-&gt;top( 0 );
             $ball-&gt;{v_y} *= -1;
         }
   
         # collision to the right: player 1 score!
         elsif ( $ball_rect-&gt;right &gt;= $app-&gt;w ) {
             $player1-&gt;{score}++;
             reset_game();
             return;
         }
    
         # collision to the left: player 2 score!
         elsif ( $ball_rect-&gt;left &lt;= 0 ) {
             $player2-&gt;{score}++;
             reset_game();
             return;
         }

         # collision with player1&#39;s paddle
         elsif ( check_collision( $ball_rect, $player1-&gt;{paddle} )) {
             $ball_rect-&gt;left( $player1-&gt;{paddle}-&gt;right );
             $ball-&gt;{v_x} *= -1;
   +         $player1-&gt;{colour} = ($player1-&gt;{colour} + 1) % @colours;
         }
    
         # collision with player2&#39;s paddle
         elsif ( check_collision( $ball_rect, $player2-&gt;{paddle} )) {
             $ball-&gt;{v_x} *= -1;
             $ball_rect-&gt;right( $player2-&gt;{paddle}-&gt;left );
   +         $player2-&gt;{colour} = ($player2-&gt;{colour} + 1) % @colours;
         }
     });</code></pre>

<p>Finally, we change our 'show' handler to use the current colour
referenced by <code>colour</code>, instead of the previously hardcoded red
(0xFF0000FF):</p>

<pre><code>      $app-&gt;add_show_handler(
          sub {
              # first, we clear the screen
              $app-&gt;draw_rect( [0, 0, $app-&gt;w, $app-&gt;h], 0x000000FF );
      
              # then we render the ball
              $app-&gt;draw_rect( $ball-&gt;{rect}, 0xFF0000FF );
      
              # ... and each paddle
    -         $app-&gt;draw_rect( $player1-&gt;{paddle}, 0xFF0000FF );
    +         $app-&gt;draw_rect( $player1-&gt;{paddle}, $colours[ $player1-&gt;{colour} ] );
    -         $app-&gt;draw_rect( $player2-&gt;{paddle}, 0xFF0000FF );
    +         $app-&gt;draw_rect( $player2-&gt;{paddle}, $colours[ $player2-&gt;{colour} ] );
  
              # ... and each player&#39;s score!
              $score-&gt;write_to(
                  $app,
                  $player1-&gt;{score} . &#39; x &#39; . $player2-&gt;{score}
              );

              # finally, we update the screen
              $app-&gt;update;
          }
      );</code></pre>

<h2>Author</h2>

<p>This chapter's content graciously provided by Breno G. de Oliveira
(<code>garu</code>).</p>

<h1>Tetris</h1>

<p>\includegraphics[width=0.5\textwidth]{../src/images/tetris.png}
\caption{Tetris using SDLx Perl} \label{fig:tetris}</p>



<h2>Eye Candy and Code</h2>

<p>In this chapter we work on creating the classic Tetris game using what
we have learned so far. Get the tetris code from
HTTPS://GitHub.Com/PerlGameDev/SDL_Manual/raw/master/games/tetris.zip. To
run the game invoke in the extracted folder.</p>

<pre><code>        perl tetris.pl</code></pre>

<h2>The Game Window</h2>

<p>First we will make our window with a fixed size so we can place our art
work in a fixed format.</p>

<pre><code>    use strict;
    use warnings;

    use SDL;
    use SDL::Event;
    use SDL::Events;
    use SDLx::App;

    # create our main screen
    my $app = SDLx::App-&gt;new(
       w            =&gt; 400,
       h            =&gt; 512,
       exit_on_quit =&gt; 1,
       dt           =&gt; 0.2,
       title        =&gt; &#39;SDLx Tetris&#39;
    );</code></pre>

<h2>Loading Artwork</h2>

<p>We can load our artwork simply by storing an array of
<code>SDLx::Surface</code>s.</p>

<pre><code>     use SDL;
    +use SDLx::Surface;
   </code></pre>

<p>Next we load up the artwork into an array.</p>

<pre><code>    +my $back  = SDLx::Surface-&gt;load( &#39;data/tetris_back.png&#39; );
    +my @piece = (undef);
    +push(@piece, SDLx::Surface-&gt;load( &quot;data/tetris_$_.png&quot; )) for(1..7);</code></pre>

<p>The background is held in the <code>$back</code> surface, and the pieces
are held in the <code>@piece</code> array. Later on we will blit these onto
our main screen as we need.</p>

<h2>Data Structures</h2>

<p>In Tetris the blocks are critical pieces of data that must be
represented in code such that it is easy to access, and quick to perform
calculations on. A hash will allow us to quickly access our pieces, based
on their keys.</p>

<pre><code>    my %pieces = (
      I =&gt; [0,5,0,0,
           0,5,0,0,
           0,5,0,0,
           0,5,0,0],
      J =&gt; [0,0,0,0,
           0,0,6,0,
           0,0,6,0,
           0,6,6,0],
      L =&gt; [0,0,0,0,
           0,2,0,0,
           0,2,0,0,
           0,2,2,0],
      O =&gt; [0,0,0,0,
           0,3,3,0,
           0,3,3,0,
           0,0,0,0],
      S =&gt; [0,0,0,0,
           0,4,4,0,
           4,4,0,0,
           0,0,0,0],
      T =&gt; [0,0,0,0,
           0,7,0,0,
           7,7,7,0,
           0,0,0,0],
      Z =&gt; [0,0,0,0,
           1,1,0,0,
           0,1,1,0,
           0,0,0,0],
    );</code></pre>

<p>Further more we have a 1-dimensional array for each piece that
represents a grid of the piece.</p>

<p>The grid of each piece is filled with empty spaces and a number from 1
to 7. When this grid is imposed on the game grid, we can use the non zero
number to draw the right piece block on to it.</p>

<p>The non zero number corresponds to the images file that we loaded
ealier.</p>

<pre><code>     push(@piece, SDLx::Surface-&gt;load( &quot;data/tetris_$_.png&quot; )) for(1..7);</code></pre>

<h2>Selecting Pieces</h2>

<pre><code>     use strict;
     use warnings;

    +use List::Util qw(shuffle min max);</code></pre>

<p>We will use the List::Util module to provide us with some neeeded
functions.</p>

<pre><code>         Z =&gt; [0,0,0,0,
               1,1,0,0,
               0,1,1,0,
               0,0,0,0],
     );

    +my $next_tile         = shuffle(keys %pieces);
    +my $curr_tile         = [undef, 4, 0];
    +   @{$curr_tile-&gt;[0]} = @{$pieces{$next_tile}};
    +   $next_tile         = shuffle(keys %pieces); </code></pre>

<p>We will randomly pick a <code>$next_tile</code> and then set the piece
data for our first piece in <code>$curr_tile</code>. Then we will pick
another tile for our <code>$next_tile</code>.</p>

<h2>Moving Pieces</h2>

<pre><code>     push(@piece, SDLx::Surface-&gt;load( &quot;data/tetris_$_.png&quot; )) for(1..7);

    +# to check for collisions we compare the position of the moving piece with the non-movin pieces
    +my $grid  = []; # moving piece
    +my $store = []; # non-moving pieces
     my %pieces = (
          I =&gt; [0,5,0,0,</code></pre>

<p>In our conceptual model of Tetris we have two grids that overlap each
other. First we have the <code>$grid</code> where the piece that is moving
is stored. Once a piece has collided with sometime we move it to
<code>$store</code> grid and hold it there until a line is cleared.</p>

<pre><code>     $next_tile         = shuffle(keys %pieces); </code></pre>

<p>To rotate a piece we apply a transformation on each element of the
piece.</p>

<pre><code>    + sub rotate_piece {
    +     my $_piece   = shift;
    +     my $_rotated = [];
    +     my $_i = 0;
    +     for(@{$_piece}) {
    +         $_rotated-&gt;[$_i + (($_i%4+1)*3) - (5*int($_i/4))] = $_;
    +         $_i++;
    +     }
    +     return $_rotated;
    + }</code></pre>

<p>Additionally we do a simple collision checking between the non zero
elements in the pieces with the direction the user wants to move.</p>

<pre><code>    + sub can_move_piece {
    +     my $direction = shift;
    +     my $amount    = shift || 1;
    +     for my $y (0..3) {
    +         for my $x (0..3) {
    +             if($curr_tile-&gt;[0]-&gt;[$x + 4 * $y]) {
    +                 return if $direction eq &#39;left&#39;  
    +                          &amp;&amp; $x - $amount + $curr_tile-&gt;[1]  &lt; 0;
    +                 return if $direction eq &#39;right&#39; 
    +                          &amp;&amp; $x + $amount + $curr_tile-&gt;[1]  &gt; 9;
    +                 return if $direction eq &#39;down&#39;  
    +                          &amp;&amp; int($y + $amount + $curr_tile-&gt;[2]) &gt; 22;
    +                 
    +                 return if $direction eq &#39;right&#39; 
    +                          &amp;&amp; $store-&gt;[ $x + $amount + 
    +                                        $curr_tile-&gt;[1] + 
    +                                        10 * int($y + $curr_tile-&gt;[2]) ];
    +                 return if $direction eq &#39;left&#39;  
    +                          &amp;&amp; $store-&gt;[ $x - $amount + 
    +                                        $curr_tile-&gt;[1] + 
    +                                        10 * int($y + $curr_tile-&gt;[2]) ];
    +                 return if $direction eq &#39;down&#39;  
    +                          &amp;&amp; $store-&gt;[ $x + 
    +                                        $curr_tile-&gt;[1] 
    +                                        + 10 * int($y + $amount + $curr_tile-&gt;[2]) ];
    +             }
    +         }
    +     }
    +     return 1;
    + }</code></pre>

<p>Finally we move the move piece by using the collision check and
overlaying the piece array into the <code>@grid</code> for each next
position.</p>

<pre><code>    + sub move_piece {
    +     my $direction = shift;
    +     my $amount    = shift || 1;
    +     if($direction eq &#39;right&#39;) {
    +         $curr_tile-&gt;[1] += $amount;
    +     }
    +     elsif($direction eq &#39;left&#39;) {
    +         $curr_tile-&gt;[1] -= $amount;
    +     }
    +     elsif($direction eq &#39;down&#39;) {
    +         $curr_tile-&gt;[2] += $amount;
    +     }
    +     
    +     @{$grid} = ();
    +     for my $y (0..3) {
    +         for my $x (0..3) {
    +             if($curr_tile-&gt;[0]-&gt;[$x + 4 * $y]) {
    +                 $grid-&gt;[ $x + $curr_tile-&gt;[1] + 10 * ($y + int($curr_tile-&gt;[2])) ] 
    +                           = $curr_tile-&gt;[0]-&gt;[$x + 4 * $y];
    +             }
    +         }
    +     }
    + }

    + sub store_piece {
    +     for my $y (0..3) {
    +         for my $x (0..3) {
    +             if($curr_tile-&gt;[0]-&gt;[$x + 4 * $y]) {
    +                 $store-&gt;[ $x + $curr_tile-&gt;[1] + 10 * ($y + int($curr_tile-&gt;[2])) ] 
    +                           = $curr_tile-&gt;[0]-&gt;[$x + 4 * $y];
    +             }
    +         }
    +     }
    + }</code></pre>

<p>Finally we hook it into the event handler where we use the events to
move the pieces in the right direction.</p>

<pre><code>    + sub trigger_move_event_handler {
    +     my ( $event, $app ) = @_;
    +     if( $event-&gt;type == SDL_KEYDOWN ) {
    +         my $key = $event-&gt;key_sym;
    +         if( $event-&gt;key_sym &amp; (SDLK_LEFT|SDLK_RIGHT|SDLK_UP|SDLK_DOWN) ) {
    +             if($key == SDLK_LEFT &amp;&amp; can_move_piece(&#39;left&#39;)) {
    +                 move_piece(&#39;left&#39;);
    +             }
    +             elsif($key == SDLK_RIGHT &amp;&amp; can_move_piece(&#39;right&#39;)) {
    +                 move_piece(&#39;right&#39;);
    +             }
    +             elsif($key == SDLK_DOWN &amp;&amp; can_move_piece(&#39;down&#39;)) {
    +                 move_piece(&#39;down&#39;)
    +             }
    +             elsif($key == SDLK_UP) {
    +                 $curr_tile-&gt;[0] = rotate_piece($curr_tile-&gt;[0]);
    +             }
    +         }
    +     }
    + }

    + $app-&gt;add_event_handler( \&amp;trigger_move_event_handler );</code></pre>

<h3>Score and Game State</h3>

<p>Next we add the move handler to update the game state. In tetris the
game state can be summarized as the grid, current piece and the score. In
this move handler we update all these things .</p>

<pre><code>    + $app-&gt;add_move_handler( sub {
    +     my ( $step, $app ) = @_;</code></pre>

<p>We update the current piece's state as movable or fixed.</p>

<pre><code>    +     if(can_move_piece(&#39;down&#39;, $step / 2)) {
    +         move_piece(&#39;down&#39;, $step / 2);
    +     }
    +     else {
    +         store_piece($curr_tile); # placing the tile
    +         </code></pre>

<p>We update the status of the grid and see if there are lines to remove. +
# checking for lines to delete + my $y; + my @to_delete = (); + for($y =
22; $y >= 0; $y--) { + # there is no space if min of this row is true
(greater than zero) + if(min(@{$store}[($y*10)..((($y+1)*10)-1)])) { +
push(@to_delete, $y); + } + }</p>

<p>When we delete lines increment the score of the user.</p>

<pre><code>    +         # deleting lines
    +         foreach(@to_delete) {
    +             splice(@{$store}, $_*10, 10);
    +             $score++;
    +         }
    +         
Next for each deleted line we clear the grid. 
    +         # adding blank rows to the top
    +         foreach(@to_delete) {
    +             splice(@{$store}, 0, 0, (0,0,0,0,0,0,0,0,0,0));
    +         }
    +         
Finally we lauch a new current tile if needed. 
    +         # launching new tile
    +         @{$curr_tile-&gt;[0]}  = @{$pieces{$next_tile}};
    +         $curr_tile-&gt;[1]     = 4;
    +         $curr_tile-&gt;[2]     = 0;
    +         $next_tile          = shuffle(keys %pieces);
    +     }
    + });</code></pre>

<h3>Showing the Game</h3>

<p>In the show handler we iterate through each element in the store and
grid array and place the right colored tile where needed (using the
numbers).</p>

<pre><code>    + # renders game objects on the screen
    + $app-&gt;add_show_handler(
    +     sub {
    +         # first, we clear the screen
    +         $app-&gt;draw_rect( [ 0, 0, $app-&gt;w, $app-&gt;h ], 0x000000 );
    +         # and draw the background image
    +         $back-&gt;blit( $app );
    +         my $x = 0;
    +         my $y = 0;
    +         # draw the not moving tiles
    +         foreach(@{$store}) {
    +             $piece[$_]-&gt;blit( $app,
    +                                undef, 
    +                               [ 28 + $x%10 * 20, 28 + $y * 20 ] 
    +                             ) if $_;
    +             $x++;
    +             $y++ unless $x % 10;
    +         }
    +         $x = 0;
    +         $y = 0;
    +         # draw the moving tile
    +         foreach(@{$grid}) {
    +             $piece[$_]-&gt;blit( $app, undef, [ 28 + $x%10 * 20, 28 + $y * 20 ] ) if $_;
    +             $x++;
    +             $y++ unless $x % 10;
    +         }
    +         # the next tile will be...
    +         my $next_tile_index = max(@{$pieces{$next_tile}});
    +         for $y (0..3) {
    +             for $x (0..3) {
    +                 if($pieces{$next_tile}-&gt;[$x + 4 * $y]) {
    +                     $piece[$next_tile_index]-&gt;blit( $app, undef, 
    +                                                     [ 264 + $x * 20, 48 + $y * 20 ] 
    +                                                   );
    +                 }
    +             }
    +         }</code></pre>

<p>Lastly we draw texts needed.</p>

<pre><code>    +         $score_text-&gt;write_xy( $app, 248,  20, &quot;Next Piece&quot; );
    +         $score_text-&gt;write_xy( $app, 248, 240, &quot;Score: $score&quot; );
    +         # finally, we update the screen
    +         $app-&gt;update;
    +     }
    + );

    + # all is set, run the app!
    + $app-&gt;run();</code></pre>

<h2>Author</h2>

<p>Code for this chapter was provided by Tobias Leich "FROGGS".</p>

<h1>Puzz! A puzzle game</h1>

<h2>Abstract</h2>

<p>We are now ready to write another complete game. Instead of listing the
code and then explaining it, I will go through the process of how I might
write it.</p>

<p>Puzz is a simple rearrangment puzzle. A random image from the folder
Puzz is in is chosen and broken into a 4x4 grid. The top left corner piece
is then taken away, and every other piece is then moved to a random
position, scrambling the image up. The goal is then to move pieces which
are in the 4 squares adjacent to the empty square on to the empty square,
and eventually restore the image.</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/puzz1.png}
\caption{Credits to Sebastian Riedel (kraih.com) for the Perl6 logo used
with permission in the application.} \label{fig:puzz}</p>



<h2>The Window</h2>

<p>So, first thing we do is create the window. I've decided I want each
piece to be 100x100, so the window needs to be 400x400.</p>

<pre><code>       use strict;
       use warnings;

       use SDL;
       use SDLx::App;

       my $App = SDLx::App-&gt;new(w =&gt; 400, h =&gt; 400, t =&gt; &#39;Puzz&#39;);</code></pre>

<p>Next thing we usually do is figure out what global vars we will be
needing. As with $App, I like to name my globals with title case, so they
are easily distinguishable from lexical vars. The globals we need are the
grid (the positions of the pieces), the images we have to use, the current
image, and a construct that will give us piece movement, along with an
animation.</p>

<pre><code>    my @Grid;
    my @Img;
    my $CurrentImg;
    my %Move;</code></pre>

<p>For now, lets fill in @Grid with what it's going to look like:</p>

<pre><code>    @Grid = (
       [0,  1,  2,  3],
       [4,  5,  6,  7],
       [8,  9,  10, 11],
       [12, 13, 14, 15],
    );</code></pre>

<p><code>0</code> will be our blank piece, but we could have chosen it to
be any other number. When the grid looks like this, it's solved, so
eventually we will need a way to scramble it. It's good enough for now,
though.</p>

<h2>Loading the images</h2>

<p>To load the images, we would normally use <code>SDLx::Surface</code>,
but we're going to do it the libsdl way with <code>SDL::Image</code>
because we need to do our own error handling.</p>

<pre><code>    use SDL::Image;
    use SDL::GFX::Rotozoom &#39;SMOOTHING_ON&#39;;

    while(&lt;./*&gt;) {
        if(-f and my $i = SDL::Image::load($_)) {
            $i = SDL::GFX::Rotozoom::surface_xy($i, 0, 400 / $i-&gt;w, 400 / $i-&gt;h, SMOOTHING_ON);
            push @Img, $i;
        }
        else
        {   
            warn &quot;Cannot Load $_: &quot; . SDL::get_error() if $_ =~ /jpg|png|bmp/;
        }
    }
    $CurrentImg = $Img[rand @Img];
    
    die &quot;Please place images in the Current Folder&quot; if $#Img &lt; 0;</code></pre>

<p>We just go through every file in the current directory, and try to load
it as an image. <code>SDL::Image::load</code> will return false if there
was an error, so we want to discard it when that happens. If we used
<code>SDLx::Surface</code> to load the images, we would get a warning every
time a file fails to load as an image, which we don't want. The <code>my $i
= SDL::Image::load($_)</code> is just an idiom for setting a var and
checking it for truth at the same time.</p>

<p>We want the image to be 400x400, and <code>SDL::GFX::Rotozoom</code>
makes this possible. The two Rotozoom functions that are the most useful
are <code>surface</code> and <code>surface_xy</code>. They work like
this:</p>

<pre><code>    $zoomed_src = SDL::GFX::Rotozoom::surface($src, $angle, $zoom, $smoothing)
    $zoomed_src = SDL::GFX::Rotozoom::surface_xy($src, $angle, $x_zoom, $y_zoom, $smoothing)</code></pre>

<p>The zoom values are the multiplier for that component, or for both
components at once as with <code>$zoom</code>. <code>$angle</code> is an
angle of rotation in degrees. <code>$smoothing</code> should be
<code>SMOOTHING_ON</code> or <code>SMOOTHING_OFF</code> (which can be
exported by <code>SDL::GFX::Rotozoom</code>) or just 1 or 0.</p>

<p>Once the image is zoomed, it is added to the image array. The current
image is then set to a random value of the array.</p>

<h2>Handling Events</h2>

<p>The next part I like to write is the events. We're going to make Escape
quit, and left click will move the pieces around. We <code>use
SDL::Events</code> for the constants.</p>

<pre><code>    use SDL::Events;

    sub on_event {
        my ($e) = @_;
        if($e-&gt;type == SDL_QUIT or $e-&gt;type == SDL_KEYDOWN and $e-&gt;key_sym == SDLK_ESCAPE) {
            $App-&gt;stop;
        }
        elsif($e-&gt;type == SDL_MOUSEBUTTONDOWN and $e-&gt;button_button == SDL_BUTTON_LEFT) {
            ...
        }
    }

    $App-&gt;add_event_handler(\&amp;on_event);
    # $App-&gt;add_move_handler(\&amp;on_move); 
    # $App-&gt;add_show_handler(\&amp;on_show);
    $App-&gt;run;</code></pre>

<h2>Filling the Grid</h2>

<p>Once we have something like this, it's a good time to put some
<code>warn</code> messages in to make sure the inputs are working
correctly. Once they are, it's time to fill it in.</p>

<pre><code>    my $x = int($e-&gt;button_x / 100);
    my $y = int($e-&gt;button_y / 100);
    if(!%Move and $Grid[$y][$x]) {`
        ...
    }</code></pre>

<p>From the pixel coordinates of the click (0 to 399), we want to find out
the grid coordinates (0 to 3), so we divide both components by 100 and
round them down. Then, we only want to continue on to see if that piece can
move if no other piece is moving (<code>%Move</code> is false), and the
piece clicked isn't the blank piece (0).</p>

<pre><code>    for([-1, 0], [0, -1], [1, 0], [0, 1]) {
        my $nx = $x + $_-&gt;[0];
        my $ny = $y + $_-&gt;[1];
        if($nx &gt;= 0 and $nx &lt; 4 and $ny &gt;= 0 and $ny &lt; 4 and !$Grid[$ny][$nx]) {
            ...
        }
    }</code></pre>

<h2>Moving the Pieces</h2>

<p>We check that the blank piece is in the 4 surrounding places by
constructing 4 vectors. These will take us to those squares. The
<code>x</code> component is first and the second is <code>y</code>. We
iterate through them, setting <code>$nx</code> and <code>$ny</code> to the
new position. Then if both <code>$nx</code> and <code>$ny</code> are within
the grid (0 to 3), and that position in the grid is 0, we can move the
piece to the blank square.</p>

<pre><code>    %Move = (
        x      =&gt; $x,
        y      =&gt; $y,
        x_dir  =&gt; $_-&gt;[0],
        y_dir  =&gt; $_-&gt;[1],
        offset =&gt; 0,
    );</code></pre>

<p>To make a piece move, we construct the move hash with all the
information it needs to move the piece. The <code>x</code> and
<code>y</code> positions of the piece, the <code>x</code> and
<code>y</code> directions it will be moving (the vector), and it's current
pixel offset from it's position (for the moving animation), which starts at
0.</p>

<h3>The Move Handler Callback</h3>

<p>Next we will write the move handler. All it needs to do is move any
moving piece along by updating the offset, and click it in to where it's
being moved to when it has moved the whole way (offset is 100 or more).</p>

<pre><code>    sub on_move {
        if(%Move) {
            $Move{offset} += 30 * $_[0];
            if($Move{offset} &gt;= 100) {
                $Grid[$Move{y} + $Move{y_dir}][$Move{x} + $Move{x_dir}] = $Grid[$Move{y}][$Move{x}];
                $Grid[$Move{y}][$Move{x}] = 0;
                undef %Move;
            }
        }
    }
    </code></pre>

<p>30 has been arbitrarily chosen as the speed of the move, as it felt the
best after a little playing and tweaking. Always remember to multiply
things like this by the step value in <code>$_[0]</code> so that the
animation moves in correct time with the updating.</p>

<p>Once the offset is 100 or more, the grid place that the piece is moving
to is set to the value of the piece, and the piece is set to the blank
value. The move is then finished, so <code>%Move</code> is deleted.</p>

<h2>Rendering the Game</h2>

<p>Now that we have all the functionality we need it's finally time to see
the game.</p>

<pre><code>    sub on_show {
        $App-&gt;draw_rect( [0,0,$App-&gt;w,$App-&gt;h], 0 );
        for my $y (0..3) {
            for my $x (0..3) {
                ...
            }
        }
        $App-&gt;flip;
    }
    </code></pre>

<p>We start the show handler by drawing a black rect over the entire app.
Entire surface and black are the defaults of <code>draw_rect</code>, so
letting it use the defaults is good. Next we iterate through a
<code>y</code> and <code>x</code> of 0 to 3 so that we can go through each
piece of the grid. At the end of the handler we update the app with a call
to <code>flip</code>.</p>

<pre><code>    next unless my $val = $Grid[$y][$x];
    my $xval = $val % 4;
    my $yval = int($val / 4);
    my $move = %Move &amp;&amp; $Move{x} == $x &amp;&amp; $Move{y} == $y;
    ...</code></pre>

<p>Inside the two loops we put this. First we set <code>$val</code> to the
grid value at the current position, and we skip to the next piece if it's
the blank piece. We have the <code>x</code> and <code>y</code> coordinates
of where that piece is on the board, but we need to figure out where it is
on the image. If you refer back to the initialisation of the grid, the two
operations to find the values should make sense. <code>$move</code> is set
with a bool of whether it is this piece that is moving, if there is a piece
moving at all.</p>

<pre><code>    $App-&gt;blit_by(
        $CurrentImg,
        [$xval * 100, $yval * 100, 100, 100],
        [$x * 100 + ($move ? $Move{offset} * $Move{x_dir} : 0),
         $y * 100 + ($move ? $Move{offset} * $Move{y_dir} : 0)]
    );</code></pre>

<p>Now that we have all of this, we can blit the portion of the current
image we need to the app. We use <code>blit_by</code> because the image
we're blitting isn't an SDLx::Surface (because we didn't load it as one),
but the app is. Here's how <code>blit_by</code> works as opposed to
<code>blit</code>:</p>

<pre><code>    $src-&gt;blit($dest, $src_rect, $dest_rect)
    $dest-&gt;blit_by($src, $src_rect, $dest_rect)</code></pre>

<p>The portion we need is from the <code>$xval</code> and
<code>$yval</code>, and where it needs to go to is from <code>$x</code> and
<code>$y</code>. All are multiplied by 100 because we're dealing with 0 to
300, not 0 to 3. If the piece is moving, the offset multiplied by the
diretion is added to the position.</p>

<p>When the code is run with all 3 handlers, we have a fully working game.
The pieces move around nicely when clicked. The only things it still needs
are a shuffled grid and a way to check if the player has won. To imlement
these two things, we will make two more functions.</p>

<pre><code>    use List::Util &#39;shuffle&#39;;

    sub new_grid {
        my @new = shuffle(0..15);
        @Grid = map { [@new[ $_*4..$_*4+3 ]] } 0..3;
        $CurrentImg = $Img[rand @Img];
    }
    </code></pre>

<p>We will replace the grid initialising we did with this sub. First it
shffles the numbers 0 through 15 with <code>List::Util::shuffle</code>.
This array is then arranged into a 2D grid with a <code>map</code> and put
in to @Grid. Setting the current image is also put into this sub.</p>

<pre><code>    sub won {
        my $correct = 0;
        for(@Grid) {
            for(@$_) {
                return 0 if $correct != $_;
                $correct++;
            }
        }
        return 1;
    }</code></pre>

<p>This sub returns whether the grid is in the winning configuration, that
is, all piece values are in order from 0 to 15.</p>

<p>Now we put a call to <code>new_grid</code> to replace the grid
initialisation we had before. We put <code>won</code> into the event
handler to make click call <code>new_grid</code> if you have won. Finally,
<code>won</code> is put into the show handler to show the blank piece if
you have won.</p>

<h2>Complete Code</h2>

<p>Here is the finished code:</p>

<pre><code>    use strict;
    use warnings;

    use SDL;
    use SDLx::App;
    use SDL::Events;
    use SDL::Image;
    use SDL::GFX::Rotozoom &#39;SMOOTHING_ON&#39;;
    use List::Util &#39;shuffle&#39;;

    my $App = SDLx::App-&gt;new(w =&gt; 400, h =&gt; 400, t =&gt; &#39;Puzz&#39;);

    my @Grid;
    my @Img;
    my $CurrentImg;
    my %Move;

    while(&lt;./*&gt;) {
        if(-f and my $i = SDL::Image::load($_)) {
            $i = SDL::GFX::Rotozoom::surface_xy($i, 0, 400 / $i-&gt;w, 400 / $i-&gt;h, SMOOTHING_ON);
            push @Img, $i;
        }
        else
        {   
            warn &quot;Cannot Load $_: &quot; . SDL::get_error() if $_ =~ /jpg|png|bmp/;
        }

    }
    
    die &quot;Please place images in the Current Folder&quot; if $#Img &lt; 0;    

    new_grid();

    sub on_event {
        my ($e) = @_;
        if($e-&gt;type == SDL_QUIT or $e-&gt;type == SDL_KEYDOWN and $e-&gt;key_sym == SDLK_ESCAPE) {
            $App-&gt;stop;
        }
        elsif($e-&gt;type == SDL_MOUSEBUTTONDOWN and $e-&gt;button_button == SDL_BUTTON_LEFT) {
            my($x, $y) = map { int($_ / 100) } $e-&gt;button_x, $e-&gt;button_y;
            if(won()) {
                new_grid();
            }
            elsif(!%Move and $Grid[$y][$x]) {
                for([-1, 0], [0, -1], [1, 0], [0, 1]) {
                    my($nx, $ny) = ($x + $_-&gt;[0], $y + $_-&gt;[1]);
                    if($nx &gt;= 0 and $nx &lt; 4 and $ny &gt;= 0 and $ny &lt; 4 and !$Grid[$ny][$nx]) {
                        %Move = (
                            x      =&gt; $x,
                            y      =&gt; $y,
                            x_dir  =&gt; $_-&gt;[0],
                            y_dir  =&gt; $_-&gt;[1],
                            offset =&gt; 0,
                        );
                    }
                }
            }
        }
    }

    sub on_move {
        if(%Move) {
            $Move{offset} += 30 * $_[0];
            if($Move{offset} &gt;= 100) {
                $Grid[$Move{y} + $Move{y_dir}][$Move{x} + $Move{x_dir}] = $Grid[$Move{y}][$Move{x}];
                $Grid[$Move{y}][$Move{x}] = 0;
                undef %Move;
            }
        }
    }

    sub on_show {
        $App-&gt;draw_rect( [0,0,$App-&gt;w,$App-&gt;h], 0 );
        for my $y (0..3) {
            for my $x (0..3) {
                next if not my $val = $Grid[$y][$x] and !won();
                my $xval = $val % 4;
                my $yval = int($val / 4);
                my $move = %Move &amp;&amp; $Move{x} == $x &amp;&amp; $Move{y} == $y;
                $App-&gt;blit_by(
                    $CurrentImg,
                    [$xval * 100, $yval * 100, 100, 100],
                    [$x * 100 + ($move ? $Move{offset} * $Move{x_dir} : 0),
                     $y * 100 + ($move ? $Move{offset} * $Move{y_dir} : 0)]
                );
            }
        }
        $App-&gt;flip;
    }

    sub new_grid {
        my @new = shuffle(0..15);
        @Grid = map { [@new[ $_*4..$_*4+3 ]] } 0..3;
        $CurrentImg = $Img[rand @Img];
    }

    sub won {
        my $correct = 0;
        for(@Grid) {
            for(@$_) {
                return 0 if $correct != $_;
                $correct++;
            }
        }
        return 1;
    }

    $App-&gt;add_event_handler(\&amp;on_event);
    $App-&gt;add_move_handler(\&amp;on_move); 
    $App-&gt;add_show_handler(\&amp;on_show);
    $App-&gt;run;</code></pre>

<p>You now hopefully know more of the process that goes in to creating a
simple game. The process of creating a complex game is similar, it just
requires more careful planning. You should have also picked up a few other
tricks, like with <code>SDL::GFX::Rotozoom</code>,
<code>SDL::Image::load</code> and <code>blit_by</code>.</p>

<h2>Activities</h2>

<ol>

<li>1. Make the blank piece the bottom right piece instead of the top left
piece.</li>

<li>2. Make the grid dimensions variable by getting the value from
<code>$ARGV[0]</code>. The grid will then be 5x5 if <code>$ARGV[0]</code>
is 5 and so on.</li>

</ol>

<h2>Author</h2>

<p>This chapter's content graciously provided by Blaizer.</p>

<h1>Sound and Music</h1>

<p>Sound and Music in SDL are handled by the <code>Audio</code> and
<code>SDL_Mixer</code> components. Enabling <code>Audio</code> devices is
provided with the Core SDL Library and only supports wav files.
<code>SDL_Mixer</code> supports more audio file formats and has additional
features that we need for sound in Game Development.</p>

<p>Similarly to video in SDL, there are several way for perl developers to
access the Sound components of SDL. For the plain <code>Audio</code>
component the <code>SDL::Audio</code> and related modules are available.
<code>SDL_Mixer</code> is supported with th <code>SDL::Mixer</code> module.
There is currently a <code>SDLx::Sound</code> module in the work, but not
completed at the time of writing this manual. For that reason this chapter
will use <code>SDL::Audio</code> and <code>SDL::Mixer</code>.</p>

<h2>Simple Sound Script</h2>

<p>To begin using sound we must enable and open an audiospec:</p>

<pre><code>   use strict;
   use warnings;
   use SDL;
   use Carp;
   use SDL::Audio;
   use SDL::Mixer;
   
   SDL::init(SDL_INIT_AUDIO);
   
   unless( SDL::Mixer::open_audio( 44100, AUDIO_S16SYS, 2, 4096 ) == 0 )
   {
      Carp::croak &quot;Cannot open audio: &quot;.SDL::get_error(); 
   }
   </code></pre>

<p><code>open_audio</code> will open an audio device with frequency at
44100 Mhz, audio format AUDIO_S16SYS (Note: This is currently the most
portable format, however there are others), 2 channels and a chunk size of
4096. Fiddle with these values if you are comfortable with sound
terminology and techniques.</p>

<h3>Loading Samples</h3>

<p>Next we will load sound samples that generally used for sound effects
and the like. Currently <code>SDL_Mixer</code> reserves samples for
<code>.WAV</code>, <code>.AIFF</code>, <code>.RIFF</code>
<code>.OGG</code>, and <code>.VOC</code> formats.</p>

<p>Samples run on one of the 2 channels that we opened up, while the other
channel will be reserved for multiple plays of the sample. To load samples
we will be doing the following:</p>

<pre><code>   +use SDL::Mixer::Samples;

   +#Brillant Lazer Sound from HTTP://FreeSound.Org/samplesViewSingle.php?id=30935
   +my $sample = SDL::Mixer::Samples::load_WAV(&#39;data/sample.wav&#39;);

   +unless($sample)
   +{
   +   Carp::croak &quot;Cannot load file data/sample.wav: &quot;.SDL::get_error();   
   +}</code></pre>

<h3>Playing the sample and closing audio</h3>

<p>Now we can play that sample on any open channel looping forever:</p>

<pre><code>    use SDL::Mixer::Samples;
   +use SDL::Mixer::Channels;
   
   my $sample =  SDL::Mixer::Samples::load_WAV(&#39;data/sample.wav&#39;);
   unless( $sample)
   {
      Carp::croak &quot;Cannot load file data/sample.wav: &quot;.SDL::get_error(); 
   }

   +my $playing_channel = SDL::Mixer::Channels::play_channel( -1, $sample, 0 );</code></pre>

<p><code>play_channel</code> allows us to assign a sample to the channel
<code>-1</code> which indicates any open channel. <code>0</code> indicates
we want to play the sample only once.</p>

<p>Note that since the sound will be playing in an external process we will
need to keep the perl script running. In a game this is no problem but for
a single script like this we can just use a simple <code>sleep</code>
function. Once we are done we can go ahead and close the audio device.</p>

<pre><code>   +sleep(1);
   +SDL::Mixer::close_audio();</code></pre>

<h3>Streaming Music</h3>

<p>Next we will use <code>SDL::Mixer::Music</code> to add a background
music to our script here.</p>

<pre><code>    use SDL::Mixer::Channels;
    +use SDL::Mixer::Music;

    +#Load our awesome music from HTTP://8BitCollective.Com
    +my $background_music = 
        +         SDL::Mixer::Music::load_MUS(&#39;data/music/01-PC-Speaker-Sorrow.ogg&#39;);


    +unless( $background_music )
    +{
    +   Carp::croak &quot;Cannot load music file data/music/01-PC-Speaker-Sorrow.ogg: &quot;.SDL::get_error() ;
    +}</code></pre>

<p>Music types in <code>SDL::Mixer</code> run in a separate channel from
our samples which allows us to have sound effects (like jump, or lasers
etc) to play at the same time.</p>

<pre><code>   +SDL::Mixer::Music::play_music($background_music,0); </code></pre>

<p><code>play_music</code> also takes a parameter for how many loops you
would like to play the song for, where 0 is 1.</p>

<p>To stop the music we can call <code>halt_music</code>.</p>

<pre><code>    sleep(2);
   +SDL::Mixer::Music::halt_music();
    SDL::Mixer::close_audio();</code></pre>

<blockquote>

<p>Controlling Volume can be as simple as:</p>

<pre><code>   #All channels indicated by the -1
   SDL::Mixer::Channels::volume(-1,10); 

   #Specifically for the Music
   SDL::Mixer::Music::volume_music( 10 );</code></pre>

<p>Volumes can be set at anytime and range from <code>1-100</code>.</p>

</blockquote>

<h3>Code so far</h3>

<pre><code>    use strict;
    use warnings;
    use SDL;
    use Carp;
    use SDL::Audio;
    use SDL::Mixer;
    use SDL::Mixer::Samples;
    use SDL::Mixer::Channels;
    use SDL::Mixer::Music;
    SDL::init(SDL_INIT_AUDIO);

    unless( SDL::Mixer::open_audio( 44100, AUDIO_S16SYS, 2, 4096 ) == 0 )
    {
        Carp::croak &quot;Cannot open audio: &quot;.SDL::get_error(); 
    }


    my $sample = SDL::Mixer::Samples::load_WAV(&#39;data/sample.wav&#39;);

    unless( $sample)
    {
        Carp::croak &quot;Cannot load file data/sample.wav: &quot;.SDL::get_error(); 
    }

    my $playing_channel = SDL::Mixer::Channels::play_channel( -1, $sample, 0 );

    #Load our awesome music from HTTP://8BitCollective.Com
    my $background_music = SDL::Mixer::Music::load_MUS(&#39;data/music/01-PC-Speaker-Sorrow.ogg&#39;);

    unless( $background_music )
    {
        Carp::croak &quot;Cannot load music file data/music/01-PC-Speaker-Sorrow.ogg: &quot;
                .SDL::get_error();
    }

    SDL::Mixer::Music::play_music( $background_music,0 );

    sleep(2);

    SDL::Mixer::Music::halt_music();
    SDL::Mixer::close_audio;</code></pre>

<h2>Sound Applications</h2>

<p>Now that we know how to prepare and play simple sounds we will apply it
to an <code>SDLx::App</code>.</p>

<h3>SDLx::App Audio Initialization</h3>

<p><code>SDLx::App</code> will initialize everything normally for us.
However for a stream line application it is recommend to initialize only
the things we need. In this case that is <code>SDL_INIT_VIDEO</code> and
<code>SDL_INIT_AUDIO</code>.</p>

<pre><code>    use strict;
    use warnings;
    use SDL;
    use Carp;
    use SDLx::App;
    use SDL::Audio;
    use SDL::Mixer;
    use SDL::Event;
    use SDL::Events;
    use SDL::Mixer::Music;
    use SDL::Mixer::Samples;
    use SDL::Mixer::Channels;

    my $app = SDLx::App-&gt;new(
        init  =&gt; SDL_INIT_AUDIO | SDL_INIT_VIDEO,
        width =&gt; 250,
        height =&gt; 75,
        title =&gt; &quot;Sound Event Demo&quot;,
        eoq   =&gt; 1
  
  );</code></pre>

<h3>Loading Resources</h3>

<p>It is highly recommended to perform all resource allocations before a
<code>SDLx::App::run()</code> method is called.</p>

<pre><code>    # Initialize the Audio
    unless ( SDL::Mixer::open_audio( 44100, AUDIO_S16SYS, 2, 4096 ) == 0 ) {
        Carp::croak &quot;Cannot open audio: &quot; . SDL::get_error();
    }

    #Something to show while we play music and sounds
    my $channel_volume = 100;
    my $music_volume   = 100;
    my $laser_status   = &#39;none&#39;;
    my $music_status   = &#39;not playing&#39;;

    # Load our sound resources
    my $laser = SDL::Mixer::Samples::load_WAV(&#39;data/sample.wav&#39;);
    unless ($laser) {
        Carp::croak &quot;Cannot load sound: &quot; . SDL::get_error();
    }

    my $background_music =
    SDL::Mixer::Music::load_MUS(&#39;data/music/01-PC-Speaker-Sorrow.ogg&#39;);
    unless ($background_music) {
        Carp::croak &quot;Cannot load music: &quot; . SDL::get_error();
    }</code></pre>

<h3>The Show Handler</h3>

<p>For the purposes of describing the current state of the music lets draw
text to the screen in a <code>show_handler</code>.</p>

<pre><code>    $app-&gt;add_show_handler(
    sub { 

        $app-&gt;draw_rect([0,0,$app-&gt;w,$app-&gt;h], 0 );

        $app-&gt;draw_gfx_text( [10,10], [255,0,0,255], &quot;Channel Volume : $channel_volume&quot; );
        $app-&gt;draw_gfx_text( [10,25], [255,0,0,255], &quot;Music Volume   : $music_volume&quot; );
        $app-&gt;draw_gfx_text( [10,40], [255,0,0,255], &quot;Laser Status   : $laser_status&quot; );
        $app-&gt;draw_gfx_text( [10,55], [255,0,0,255], &quot;Music Status   : $music_status&quot; );

        $app-&gt;update();

    }
    );</code></pre>

<p>This will draw the channel volume of our samples, and the volume of the
music. It will also print the status of our two sounds in the
application.</p>

<h3>The Event Handler</h3>

<p>Finally our event handler will do the actual leg work and trigger the
music and sound as we need it.</p>

<pre><code>    $app-&gt;add_event_handler(
        sub {
            my $event = shift;

            if ( $event-&gt;type == SDL_KEYDOWN ) {
                my $keysym  = $event-&gt;key_sym;
                my $keyname = SDL::Events::get_key_name($keysym);

                if ( $keyname eq &#39;space&#39; ) {

                    $laser_status = &#39;PEW!&#39;;
                    #fire lasers!
                    SDL::Mixer::Channels::play_channel( -1, $laser, 0 );

                }
                elsif ( $keyname eq &#39;up&#39; ) {
                    $channel_volume += 5 unless $channel_volume == 100;
                }
                elsif ( $keyname eq &#39;down&#39; ) {
                    $channel_volume -= 5 unless $channel_volume == 0;
                }
                elsif ( $keyname eq &#39;right&#39; ) {
                    $music_volume += 5 unless $music_volume == 100;
                }
                elsif ( $keyname eq &#39;left&#39; ) {
                    $music_volume -= 5 unless $music_volume == 0;
                }
                elsif ( $keyname eq &#39;return&#39; ) {
                    my $playing = SDL::Mixer::Music::playing_music();
                    my $paused  = SDL::Mixer::Music::paused_music();

                    if ( $playing == 0 &amp;&amp; $paused == 0 ) {
                        SDL::Mixer::Music::play_music( $background_music, 1 );
                        $music_status = &#39;playing&#39;;
                    }
                    elsif ( $playing &amp;&amp; !$paused ) {
                        SDL::Mixer::Music::pause_music();
                        $music_status = &#39;paused&#39;
                    }
                    elsif ( $playing &amp;&amp; $paused ) {
                        SDL::Mixer::Music::resume_music();
                        $music_status = &#39;resumed playing&#39;;
                    }

                }

                SDL::Mixer::Channels::volume( -1, $channel_volume );
                SDL::Mixer::Music::volume_music($music_volume);

            }

          }

    );</code></pre>

<p>The above event handler fires the laser on pressing the 'Space' key. Go
ahead and press it multiple times as if you are firing a gun in a game! You
will notice that depending on how fast you fire the laser the application
will still manage to overlap the sounds as needed. The sample overlapping
is accomplished by requiring multiple channels in the
<code>open_audio</code> call. If your game has lots of samples that may
play at the same time you may need more channels allocated. Additionally
you can see that the volume control is easily managed both on the channels
and the music with just incrementing or decrementing a value and calling
the appropriate function.</p>

<p>Finally it is worth noticing the various state the background music can
be in.</p>

<p>Lets run this application and the make sure to clean up the audio on the
way out. $app->run(); SDL::Mixer::Music::halt_music();
SDL::Mixer::close_audio;</p>

<h3>Completed Code</h3>

<pre><code>    use strict;
    use warnings;

    use Cwd;
    use Carp;
    use File::Spec;

    use threads;
    use threads::shared;

    use SDL;
    use SDL::Event;
    use SDL::Events;

    use SDL::Audio;
    use SDL::Mixer;
    use SDL::Mixer::Music;
    use SDL::Mixer::Effects;

    use SDLx::App;
    my $app = SDLx::App-&gt;new(
        init   =&gt; SDL_INIT_AUDIO | SDL_INIT_VIDEO,
        width  =&gt; 800,
        height =&gt; 600,
        depth  =&gt; 32,
        title  =&gt; &quot;Music Visualizer&quot;,
        eoq    =&gt; 1,
        dt     =&gt; 0.2,
    );

    # Initialize the Audio
    unless ( SDL::Mixer::open_audio( 44100, AUDIO_S16, 2, 1024 ) == 0 ) {
        Carp::croak &quot;Cannot open audio: &quot; . SDL::get_error();
    }

    # Load our music files
    my $data_dir = &#39;.&#39;;
    my @songs    = glob &#39;data/music/*.ogg&#39;;

    my @stream_data : shared;

    #  Music Effect to pull Stream Data
    sub music_data {
        my ( $channel, $samples, $position, @stream ) = @_;

        {
            lock(@stream_data);
            push @stream_data, @stream;
        }

        return @stream;
    }

    sub done_music_data { }

    my $music_data_effect_id =
      SDL::Mixer::Effects::register( MIX_CHANNEL_POST, &quot;main::music_data&quot;,
        &quot;main::done_music_data&quot;, 0 );

    #  Music Playing Callbacks
    my $current_song = 0;
    my $lines = $ARGV[0] || 50;

    my $current_music_callback = sub {
        my ( $delta, $app ) = @_;

        $app-&gt;draw_rect( [ 0, 0, $app-&gt;w(), $app-&gt;h() ], 0x000000FF );
        $app-&gt;draw_gfx_text(
            [ 5, $app-&gt;h() - 10 ],
            [ 255, 0, 0, 255 ],
            &quot;Playing Song: &quot; . $songs[ $current_song - 1 ]
        );

        my @stream;
        {
            lock @stream_data;
            @stream      = @stream_data;
            @stream_data = ();
        }

        # To show the right amount of lines we choose a cut of the stream
        # this is purely for asthetic reasons.

        my $cut = @stream / $lines;

        # The width of each line is calculated to use.
        my $l_wdt = ( $app-&gt;w() / $lines ) / 2;

        for ( my $i = 0 ; $i &lt; $#stream ; $i += $cut ) {

            #  In stereo mode the stream is split between two alternating streams
            my $left  = $stream[$i];
            my $right = $stream[ $i + 1 ];

            #  For each bar we calculate a Y point and a X point
            my $point_y = ( ( ($left) ) * $app-&gt;h() / 4 / 32000 ) + ( $app-&gt;h / 2 );
            my $point_y_r =
              ( ( ($right) ) * $app-&gt;h() / 4 / 32000 ) + ( $app-&gt;h / 2 );
            my $point_x = ( $i / @stream ) * $app-&gt;w;

            # Using the parameters
            #   Surface, box coordinates and color as RGBA
            SDL::GFX::Primitives::box_RGBA(
                $app,
                $point_x - $l_wdt,
                $app-&gt;h() / 2,
                $point_x + $l_wdt,
                $point_y, 40, 0, 255, 128
            );
            SDL::GFX::Primitives::box_RGBA(
                $app,
                $point_x - $l_wdt,
                $app-&gt;h() / 2,
                $point_x + $l_wdt,
                $point_y_r, 255, 0, 40, 128
            );

        }

        $app-&gt;flip();

    };

    my $cms_move_callback_id;
    my $pns_move_callback_id;
    my $play_next_song_callback;

    sub music_finished_playing {
        SDL::Mixer::Music::halt_music();

        $pns_move_callback_id = $app-&gt;add_move_handler($play_next_song_callback)
          if ( defined $play_next_song_callback );

    }

    $play_next_song_callback = sub {
        return $app-&gt;stop() if $current_song &gt;= @songs;
        my $song = SDL::Mixer::Music::load_MUS( $songs[ $current_song++ ] );
        SDL::Mixer::Music::play_music( $song, 0 );

        $app-&gt;remove_move_handler($pns_move_callback_id)
          if defined $pns_move_callback_id;
    };

    $app-&gt;add_show_handler($current_music_callback);
    $pns_move_callback_id = $app-&gt;add_move_handler($play_next_song_callback);

    $app-&gt;add_move_handler(
        sub {
            my $music_playing = SDL::Mixer::Music::playing_music();

            music_finished_playing() unless $music_playing;

        }
    );

    $app-&gt;add_event_handler(
        sub {
            my ( $event, $app ) = @_;
            if ( $event-&gt;type == SDL_KEYDOWN &amp;&amp; $event-&gt;key_sym == SDLK_DOWN ) {

                # Indicate that we are done playing the music_finished_playing
                music_finished_playing();
            }
        }
    );

    $app-&gt;run();

    SDL::Mixer::Effects::unregister( MIX_CHANNEL_POST, $music_data_effect_id );
    SDL::Mixer::Music::hook_music_finished();
    SDL::Mixer::Music::halt_music();
    SDL::Mixer::close_audio();</code></pre>

<h2>Music Visualizer</h2>

<p>The music visualizer example processes real-time sound data--data as it
plays--and displays the wave form on the screen. It will look something
like:</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/spectro-1.png}
\caption{Simple Music Visualization} \label{fig:Visualization}</p>



<h3>The Code and Comments</h3>

<p>The program begins with the usual boilerplate of an SDL Perl
application:</p>

<pre><code>        use strict;
        use warnings;

        use Cwd;
        use Carp;
        use File::Spec;

        use threads;
        use threads::shared;

        use SDL;
        use SDL::Event;
        use SDL::Events;

        use SDL::Audio;
        use SDL::Mixer;
        use SDL::Mixer::Music;
        use SDL::Mixer::Effects;

        use SDLx::App;</code></pre>

<p>It then creates an application with both audio and video support:</p>

<pre><code>        my $app = SDLx::App-&gt;new(
                init   =&gt; SDL_INIT_AUDIO | SDL_INIT_VIDEO,
                width  =&gt; 800,
                height =&gt; 600,
                depth  =&gt; 32,
                title  =&gt; &quot;Sound Event Demo&quot;,
                eoq    =&gt; 1,
                dt     =&gt; 0.2,
        );</code></pre>

<p>The application must initialize the audio system with a format matching
the expected audio input. <code>AUDIO_S16</code> provides a 16-bit signed
integer array for the stream data:</p>

<pre><code>        # Initialize the Audio
        unless ( SDL::Mixer::open_audio( 44100, AUDIO_S16, 2, 1024 ) == 0 ) {
                Carp::croak &quot;Cannot open audio: &quot; . SDL::get_error();
        }</code></pre>

<p>The music player needs the music files from the <i>data/music/</i>
directory:</p>

<pre><code>        # Load our music files
        my $data_dir = &#39;.&#39;;
        my @songs = glob &#39;data/music/*.ogg&#39;;</code></pre>

<p>A music effect reads stream data, then serializes it to share between
threads:</p>

<pre><code>    my @stream_data : shared;

    #  Music Effect to pull Stream Data
    sub music_data {
        my ( $channel, $samples, $position, @stream ) = @_;

        {
            lock(@stream_data);
            push @stream_data, @stream;
        }

        return @stream;
    }

    sub done_music_data { }</code></pre>

<p>... and that effect gets registered as a callback with
<code>SDL::Mixer::Effects</code>:</p>

<pre><code>        my $music_data_effect_id = 
                  SDL::Mixer::Effects::register( MIX_CHANNEL_POST, &quot;main::music_data&quot;,
                        &quot;main::done_music_data&quot;, 0 );</code></pre>

<p>The program's single command-line option governs the number of lines to
display in the visualizer. The default is 50.</p>

<pre><code>    my $lines = $ARGV[0] || 50;</code></pre>

<p>The drawing callback for the <code>SDLx::App</code> runs while a song
plays. It reads the stream data and displays it on the screen as a wave
form. The math behind calculating the graphics to display is more detail
than this article intends, but the graphic code is straightforward:</p>

<pre><code>    #  Music Playing Callbacks
    my $current_song = 0;

    my $current_music_callback = sub {
        my ( $delta, $app ) = @_;

        $app-&gt;draw_rect( [ 0, 0, $app-&gt;w(), $app-&gt;h() ], 0x000000FF );
        $app-&gt;draw_gfx_text(
            [ 5, $app-&gt;h() - 10 ],
            [ 255, 0, 0, 255 ],
            &quot;Playing Song: &quot; . $songs[ $current_song - 1 ]
        );

        my @stream;
        {
            lock @stream_data;
            @stream      = @stream_data;
            @stream_data = ();
        }

        # To show the right amount of lines we choose a cut of the stream
        # this is purely for asthetic reasons.

        my $cut = @stream / $lines;

        # The width of each line is calculated to use.
        my $l_wdt = ( $app-&gt;w() / $lines ) / 2;

        for ( my $i = 0 ; $i &lt; $#stream ; $i += $cut ) {

            #  In stereo mode the stream is split between two alternating streams
            my $left  = $stream[$i];
            my $right = $stream[ $i + 1 ];

            #  For each bar we calculate a Y point and a X point
            my $point_y = ( ( ($left) ) * $app-&gt;h() / 4 / 32000 ) + ( $app-&gt;h / 2 );
            my $point_y_r =
              ( ( ($right) ) * $app-&gt;h() / 4 / 32000 ) + ( $app-&gt;h / 2 );
            my $point_x = ( $i / @stream ) * $app-&gt;w;

            # Using the parameters
            #   Surface, box coordinates and color as RGBA
            SDL::GFX::Primitives::box_RGBA(
                $app,
                $point_x - $l_wdt,
                $app-&gt;h() / 2,
                $point_x + $l_wdt,
                $point_y, 40, 0, 255, 128
            );
            SDL::GFX::Primitives::box_RGBA(
                $app,
                $point_x - $l_wdt,
                $app-&gt;h() / 2,
                $point_x + $l_wdt,
                $point_y_r, 255, 0, 40, 128
            );

        }

        $app-&gt;flip();

    };</code></pre>

<p>Whenever a song finishes <code>SDL::Mixer::Music::playing_music</code>
returns <code>0</code>. We detect this change in state and call
<code>music_finished_playing()</code> where the program attaches our
<code>$play_next_song_callback</code> callback to switch to the next song
gracefully:</p>

<pre><code>    my $cms_move_callback_id;
    my $pns_move_callback_id;
    my $play_next_song_callback;

    sub music_finished_playing {
        SDL::Mixer::Music::halt_music();
        $pns_move_callback_id = $app-&gt;add_move_handler($play_next_song_callback)
          if ( defined $play_next_song_callback );

    }

    $play_next_song_callback = sub {
        return $app-&gt;stop() if $current_song &gt;= @songs;
        my $song = SDL::Mixer::Music::load_MUS( $songs[ $current_song++ ] );
        SDL::Mixer::Music::play_music( $song, 0 );

        $app-&gt;remove_move_handler($pns_move_callback_id)
          if defined $pns_move_callback_id;
    };</code></pre>

<p>A move handler is attached to detect if music is playing or not:</p>

<pre><code>    $app-&gt;add_move_handler(
        sub {
            my $music_playing = SDL::Mixer::Music::playing_music();
            music_finished_playing() unless $music_playing;
        }
    )       </code></pre>

<p>The first callback to trigger the <code>$play_next_song_callback</code>
gets the first song:</p>

<pre><code>        $app-&gt;add_show_handler($current_music_callback);
    $pns_move_callback_id = $app-&gt;add_move_handler($play_next_song_callback);</code></pre>

<p>... and a keyboard event handler for a keypress allows the user to move
through songs:</p>

<pre><code>        $app-&gt;add_event_handler(
        sub {
                my ($event, $app) = @_;

                if( $event-&gt;type == SDL_KEYDOWN &amp;&amp; $event-&gt;key_sym == SDLK_DOWN)
                {       
                        #Indicate that we are done playing the music_finished_playing
                        music_finished_playing();
                }

        }
        );</code></pre>

<p>From there, the application is ready to run:</p>

<pre><code>        $app-&gt;run();</code></pre>

<p>... and the final code gracefully stops <code>SDL::Mixer</code>:</p>

<pre><code>        SDL::Mixer::Effects::unregister( MIX_CHANNEL_POST, $music_data_effect_id );
        SDL::Mixer::Music::hook_music_finished();
        SDL::Mixer::Music::halt_music();
        SDL::Mixer::close_audio();</code></pre>

<p>The result? Several dozen lines of code to glue together the SDL mixer
and display a real-time visualization of the music.</p>

<h1>CPAN</h1>

<p>The Comprehensive Perl Archive Network (CPAN) is the other part of the
Perl language. By now most Perl developers should be aware of how to search
and get modules from CPAN. This chapter will focus on why to use CPAN for
games. Next we will take a look in what domain (Model, View or Controller)
does a module solve a problem for. Moreover we would want to look at what
is criteria to pick one module from another, using the many tools provided
by CPAN.</p>

<h2>Modules</h2>

<p>It is good to reuse code.</p>

<h3>MVC Method</h3>

<p>See where the module fits, Model, View or Controller</p>

<h4>View</h4>

<p>SDL will do most but helper module (Clipboard) are cool to have.</p>

<p>The <i>SDLx::Widget</i> bundle comes separately, but is meant to provide
you with several common game elements such as menu, dialog boxes and
buttons, all seamlessly integrated with SDL.</p>

<h4>Model</h4>

<p>The logic and modelling behind most popular games is already on CPAN, so
you can easily plug them in to create a new game of Chess, Checkers, Go,
Life, Minesweeping, Cards, etc. There are even classes for platform games
(like <i>Games::Nintendo::Mario</i>), creating and solving mazes,
generating random dungeon maps, you name it. Have a look at
<i>Roguelike-Utils</i> and <i>Games::RolePlay::MapGen</i> for just a few of
those.</p>

<p>If your game needs to store data, like objects and status for saved
games or checkpoints, you can use <i>Storable</i> or any of the many data
serializers available.</p>

<p>In fact, speaking of data structures, it is common to keep game data in
standard formats such as JSON, YAML or XML, to make you able to
import/export them directly from third-party tools like visual map makers
or 3D modeling software. Perl provides very nice modules to handle the most
popular formats - and some pretty unusual ones. Parsers vary in speed, size
and thoroughness, so make sure to check the possible candidates and use the
one that fits your needs for speed, size and accuracy.</p>

<h4>Controller</h4>

<p>If you need to roll a dice, you can use <i>Games::Dice</i>, that even
lets you receive an array of rolled dice, and use RPG-like syntax (e.g.
"2d6+1" for 2 rolls of a 6-side die, adding 1 to the result).</p>

<p>You can also use <i>Sub::Frequency</i> if you need to do something or
trigger a particular action or event only sometimes, or at a given
probability.</p>

<p>Your game may need you to mix words, find substrings or manipulate word
permutations in any way (like when playing scrabble), in which case you
might find the <i>Games::Word</i> module useful.</p>

<h2>Picking Modules</h2>

<p>So, you thought of a nice game, identified your needs, typed some
keywords in HTTP://Search.CPAN.Org, and got tons of results. What now? How
to avoid vaporware and find the perfect solution for your needs?</p>

<h3>Documentation</h3>

<p>Once you find a potential module for your application, make sure you
will know how to use it. Take a look at the SYNOPSIS section of the module,
it should contain some code snippets showing you how to use the module's
main features. Are you comfortable with the usage syntax? Does it seem to
do what you expect it to? Will it fit nicely to whatever it is you're
coding?</p>

<p>Next, skim through the rest of the documentation. Is it solid enough for
you? Does it look complete enough for your needs, or is it easily
extendable?</p>

<h3>License</h3>

<p>It's useless to find a module you can't legally use. Most (if not all)
modules in HTTP://Search.CPAN.Org are free and open source software, but
even so each needs a license telling developers what they can and cannot do
with it. A lot of CPAN modules are released <i>"under the same terms as
Perl itself"</i>, and this means you can pick between the Artistic License
or the GPL (version 1).</p>

<p>Below is a short and incomplete list of some popular license choices by
CPAN developers:</p>

<ul>

<li>Artistic License - HTTP://Dev.Perl.Org/licenses/artistic.html</li>

<li>GPL (all versions and variations) - HTTP://GNU.Org/licenses</li>

<li>MIT License - HTTP://OpenSource.Org/licenses/mit-license.php</li>

</ul>

<p>See HTTP://OpenSource.Org/licenses/alphabetical for a comprehensive list
with each license's full documentation.</p>

<p>You should be able to find the module's license by going to a "LICENSE
AND COPYRIGHT" section, usually available at the bottom of the
documentation, or by looking for a license file inside that
distribution.</p>

<p><b>Note:</b> Some modules might even be released into CPAN as <i>public
domain</i>, meaning they are not covered by intellectual property rights at
all, and you are free to use them as you see fit. Even so, it's usually
considered polite to mention authors as a courtesy, you know, giving credit
where credit is due.</p>

<h3>Ratings</h3>

<p>The CPAN Ratings is a service where developers rate modules they used
for their own projects, and is a great way to have some actual feedback on
how it was to use the code on a real application. The ratings are compiled
into a 1 to 5 grade, and displayed below the module name on CPAN. You can
click on the <i>"Reviews"</i> link right next to the rating stars to see
any additional comments by the reviewers, praising, criticizing or giving
some additional comments or the distribution and/or its competition.</p>

<h3>Dependencies</h3>

<p>Modules exist so you don't have to reinvent the wheel, and for that same
reason each usually depends on one or more modules itself. Don't worry if a
module depends on several others - code reusability is a good thing.</p>

<p>You may, however, be interested in <b>which</b> modules it depends on,
or, more practically, in the likelihood of a clean installation by your
users. For that, you can browse to HTTP://Deps.CPANTesters.Org and input
the module's name on the search box.</p>

<p>The CPAN Testers is a collaborative matrix designed to help developers
test their modules in several different platforms, with over a hundred
testers each month making more than 3 million reports of CPAN modules. This
particular CPAN Testers service will show you a list of dependencies and
test results for each of them, calculating the average chance of all tests
passing (for any platform).</p>

<p>While seeing all the dependencies and test results of a couple of
modules that do the same thing might help you make your pick, it's
important to realize that the <i>"chance of all tests passing"</i>
information at the bottom of the results means very little. This is because
test failures can rarely be considered independent events, and are usually
tied to not running on a specific type of operating system, to the perl
version, or even due to the tester running out of memory for reasons that
may not even concern the module being evaluated. If you don't care about
your application running on AIX or on perl 5.6.0, why would you dismiss a
module that only fails on those conditions?</p>

<h3>CPAN Testers Charts</h3>

<p>So, how do you know the actual test results for a module on the CPAN?
How can you tell if that module will run in your target machine according
to architecture, operating system and perl version?</p>

<p>The CPAN Testers website at HTTP://CPANTesters.Org offers a direct
search for distributions by name or author. To see the results for the SDL
module, for instance, you can go to
HTTP://CPANTesters.Org/distro/S/SDL.html. You can also find a test report
summary directly on CPAN, by selecting the distribution and looking at the
<i>"CPAN Testers"</i> line. If you click on the <i>"View Reports"</i> link,
you'll be redirected to the proper CPAN Testers page, like the one shown
above.</p>

<p>The first chart is a PASS summary, containing information about the most
recent version of that module with at least one <i>PASS</i> report
submitted, separated by platform and perl version.</p>

<p>Second is a list of selected reports, detailing all the submitted test
results for the latest version of the given module. If you see a
<i>FAIL</i> or <i>UNKNOWN</i> result that might concern you - usually at a
platform you expect your application to run - you can click on it to see a
verbose output of all the tests, to see why it failed.</p>

<p>Another interesting information displayed is the report summary on the
left sidebar, showing a small colored graph of PASS-UNKNOWN-FAIL results
for the latest versions of the chosen module. If you see a released version
with lots of FAIL results, it might be interesting to dig deeper or simply
require a greater version of that module in your application.</p>

<h4>Bug Reports</h4>

<p>When picking a module to use, it is very important to check out its bug
reports. You can do that by either clicking on the <i>"View/Report
Bugs"</i> link on the module's page on CPAN, or on the <i>"CPAN RT"</i>
(for Request Tracker) box on the right side of the documentation page.</p>

<p>Look for open bugs and their description - i.e. if it's a bug or a
whislist - and see if it concerns your planned usage for that module. Some
bug reports are simple notices about a typo on the documentation or a very
specific issue, so make sure you look around the ticket description to see
if it's something that blocks your usage, or if you can live with it, at
least until the author delivers an update.</p>

<p>It may also interest you to see how long the open bugs have been there.
Distributions with bugs dating for more than two years might indicate that
the author abandoned the module to pursue other projects, so you'll likely
be on your own if you find any bumps. Of course, being free software, that
doesn't mean you can't fix things yourself, and maybe even ask the author
for maintainance privileges so you can update your fixes for other people
to use.</p>

<h3>Release Date</h3>

<p>A old distribution might mean a solid and stable distribution, but it
can also mean that the author doesn't care much about it anymore. If you
find a module whose latest version is over 5 years old, make sure to double
check test results and bug reports, as explained above.</p>

<h2>Conclusion</h2>

<p>CPAN is an amazing repository filled with nice modules ready for you to
use in your games. More than often you'll find that 90% of your application
is already done on CPAN, and all you have to do to get that awesome idea
implemented is glue them together, worrying only about your application's
own logic instead of boring sidework. This means faster development, and
more fun!</p>

<h2>Author</h2>

<p>This chapter's content graciously provided by Breno G. de Oliveira
(<code>garu</code>).</p>

<h1>Pixel Effects</h1>

<p>In this chapter we will look at how to use pixel effects in Perl. Pixel
effects are operations that are done directly on the bank of a
<code>SDL_Surface</code>'s pixel. These effects are used to do visual
effects in games and applications, most notably by <code>Frozen
Bubble</code>.</p>

<p>\includegraphics[h!][width=0.5\textwidth]{../src/images/effects.png}
\caption{Snow Effect covering Frozen Bubble's Logo }
\label{fig:frozen_bubble}</p>



<p>These effects can be done in purely in Perl, for 1 passes and non real
time applications. Effects that need to be done real time will have to be
done in C via XS. This chapter will show two methods of doing this.</p>

<h2>Sol's Ripple Effect</h2>

<p>For our first pixel effect we will be doing is a ripple effect from a
well known SDL resource, HTTP://Sol.Gfxile.Net/gp/ch02.html. This effects
uses <code>SDL::get_ticks</code> to animate a ripple effect across the
surface as seen in the following figure.</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/xs_effects.png}
\caption{Sol's Chapter 01 Ripple Effect} \label{fig:ripple}</p>



<h3>Pure Perl</h3>

<p>First lets make the effect in pure Perl. To do any operations with a
<code>SDL::Surface</code> we must do
<code>SDL::Video::lock_surface()</code> call as seen below. Locking the
surface prevents other process in SDL from accessing the surface. The
surface pixels can be accessed several ways from Perl. Here we are using
the <code>SDL::Surface::set_pixels</code> which takes an offset for the
<code>SDL_Surface</code> pixels array, and sets a value there for us. The
actual pixel effect is just a time dependent (using
<code>SDL::get_ticks</code> for time) render of a function. See
HTTP://Sol.Gfxile.Net/gp/ch02.html for a deeper explanation.</p>

<pre><code>    use strict;
    use warnings;

    use SDL;
    use SDLx::App;

        # Render callback that we use to fiddle the colors on the surface
    sub render {
        my $screen = shift;
        if ( SDL::Video::MUSTLOCK($screen) ) {
            return if ( SDL::Video::lock_surface($screen) &lt; 0 );
        }

        my $ticks = SDL::get_ticks();
        my ( $i, $y, $yofs, $ofs ) = ( 0, 0, 0, 0 );
        for ( $i = 0; $i &lt; 480; $i++ ) {
            for ( my $j = 0, $ofs = $yofs; $j &lt; 640; $j++, $ofs++ ) {
                $screen-&gt;set_pixels( $ofs, ( $i * $i + $j * $j + $ticks ) );
            }
            $yofs += $screen-&gt;pitch / 4;
        }


        SDL::Video::unlock_surface($screen) if ( SDL::Video::MUSTLOCK($screen) );

        SDL::Video::update_rect( $screen, 0, 0, 640, 480 );

        return 0;
    }


    my $app = SDLx::App-&gt;new( width =&gt; 640,
                              height =&gt; 480, 
                              eoq =&gt; 1, 
                              title =&gt; &quot;Grovvy XS Effects&quot; );

    $app-&gt;add_show_handler( sub{ render( $app ) } );

    $app-&gt;run();</code></pre>

<p>One you run this program you will find it pretty much maxing out the CPU
and not running very smoothly. At this point running a loop through the
entire pixel bank of a <code>640x480</code> sized screen is too much for
Perl. We will need to move the intensive calculations to
<code>C</code>.</p>

<h3>Inline Effects </h3>

<p>In the below example we use <code>Inline</code> to write Inline
<code>C</code> code to handle the pixel effect for us. <code>SDL</code> now
provides support to work with <code>Inline</code>. The <code>render</code>
callback is now moved to <code>C</code> code, using <code>Inline C</code>.
When the program first runs it will compile the code and link it in for
us.</p>

<pre><code>    use strict;
    use warnings;
    use Inline with =&gt; &#39;SDL&#39;;
    use SDL;
    use SDLx::App;


    my $app = SDLx::App-&gt;new( width =&gt; 640, 
                              height =&gt; 480, 
                              eoq =&gt; 1, 
                              title =&gt; &quot;Grovvy XS Effects&quot; );

        # Make render a callback which has the expected signature from show_handlers
    $app-&gt;add_show_handler( \&amp;render);

    $app-&gt;run();

    use Inline C =&gt; &lt;&lt;&#39;END&#39;;

        // Show handlers recieve both float and the SDLx::App which is a SDL_Screen
    void render( float delta, SDL_Surface *screen )
    {   
        // Lock surface if needed
        if (SDL_MUSTLOCK(screen)) 
            if (SDL_LockSurface(screen) &lt; 0) 
                return;

        // Ask SDL for the time in milliseconds
        int tick = SDL_GetTicks();

        // Declare a couple of variables
        int i, j, yofs, ofs;

        // Draw to screen
        yofs = 0;
        for (i = 0; i &lt; 480; i++)
        {
            for (j = 0, ofs = yofs; j &lt; 640; j++, ofs++)
            {
                ((unsigned int*)screen-&gt;pixels)[ofs] = i * i + j * j + tick;
            }
            yofs += screen-&gt;pitch / 4;
        }

        // Unlock if needed
        if (SDL_MUSTLOCK(screen)) 
            SDL_UnlockSurface(screen);

        // Tell SDL to update the whole screen
        SDL_UpdateRect(screen, 0, 0, 640, 480);    
    }

    END</code></pre>

<h1>Additional Modules</h1>

<h2>PDL</h2>

<p>The Perl Data Language (PDL) is a tool aimed at a more scientific crowd.
Accuracy is paramount and speed is the name of the game. PDL brings to Perl
fast matrix and numerical calculations. For games in most cases a accuracy
is not critical, but speed and efficiency is a great concern. For this
reason we will briefly explore how to share SDL texture data between PDL
and OpenGL.</p>

<p>This example will do the following:</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/pdl.png}
\caption{Not terribly interesting, but the speed is phenomenal}
\label{fig:pdl}</p>



<h3>Make the application</h3>

<p>Let's start an application to use with PDL. Make sure you do <code>use
PDL</code>.</p>

<pre><code>    + use strict;
    + use warnings;
    + use SDL;
    + use SDL::Video;
    + use SDLx::App;
    +
    + use PDL;
    +
    + my $app = SDLx::App-&gt;new(
    +                           title =&gt; &#39;PDL and SDL application&#39;,
    +                           width =&gt; 640, height =&gt; 480, depth =&gt; 32,
    +                           eoq =&gt; 1);</code></pre>

<h3>Attaching the Piddle</h3>

<p>PDL core object is something called a piddle. To be able to perform PDL
calculations and show them on SDL surfaces, we need to share the memory
between them. SDL Surface memory is stored in a <code>void *</code> block
called <code>pixels</code>. <code>void *</code> memory has the property
that allows Surfaces to have varying depth, and pixel formats. This also
means that we can have PDL's memory as our <code>pixels</code> for our
surface.</p>

<pre><code>    + sub make_surface_piddle {
    + my ( $bytes_per_pixel, $width, $height) = @_;
    + my $piddle = zeros( byte, $bytes_per_pixel, $width, $height );
    + my $pointer = $piddle-&gt;get_dataref();</code></pre>

<p>At this point we have a pointer to the <code>$piddle</code>'s memory
with the given specifications. Next we have our surface use that
memory.</p>

<pre><code>    + my $s = SDL::Surface-&gt;new_form( 
    +                                       $pointer, $width, $height, 32, 
    +                                       $width * $bytes_per_pixel 
    +                                      );
    +
    + #Wrap it into a SDLx::Surface for ease of use
    + my $surface = SDLx::Surface-&gt;new( surface =&gt; $s );
    +
    + return ( $piddle, $surface );
    + } </code></pre>

<p>Lets make some global variables to hold our <code>$piddle</code> and
<code>$surface</code>.</p>

<pre><code>    + my ( $piddle, $surface ) = make_surface_piddle( 4, 400, 200 ); </code></pre>

<h3>Drawing and Updating</h3>

<p><code>make_surface_piddle()</code> will return to use an anonymous array
with a <code>$piddle</code> and <code>$surface</code> which we can use with
PDL and SDL. PDL will be used to operate on the <code>$piddle</code>. SDL
will be used to update the <code>$surface</code> and render it to the
<code>SDLx::App</code>.</p>

<pre><code>    + $app-&gt;add_move_handler( sub {
    +
    +   SDL::Video::lock_surface($surface);
    + 
    +   $piddle-&gt;mslice( &#39;X&#39;,
    +   [ rand(400), rand(400), 1 ],
    +   [ rand(200), rand(200), 1 ] 
    +   ) .= pdl( rand(225), rand(225), rand(225), 255 );
    +
    +   SDL::Video::unlock_surface($surface);
    + } );</code></pre>

<p><code>SDL::Video::lock_surface</code> prevents SDL from doing any
operations on the <code>$surface</code> until
<code>SDL::Video::unlock_surface</code> is called. Next we will blit this
surface onto the <code>$app</code>.</p>

<p>In this case we use PDL to draw random rectangles of random color.</p>

<h3>Running the App</h3>

<p>Finally we blit the <code>$surface</code> and update the
<code>$app</code>.</p>

<pre><code>    + $app-&gt;add_show_handler( sub {
    +
    +    $surface-&gt;blit( $app, [0,0,$surface-&gt;w,$surface-&gt;h], [10,10,0,0] );
    +    $app-&gt;update();
    +
    + });

    + $app-&gt;run();</code></pre>

<h3>Complete Program</h3>

<pre><code>    use strict;
    use warnings;
    use SDLx::App;

    use PDL;

    my $app = SDLx::App-&gt;new(
            title =&gt; &quot;PDL and SDL aplication&quot;,
            width =&gt; 640, height =&gt; 480, eoq =&gt; 1 );


    sub make_surface_piddle {
        my ( $bytes_per_pixel, $width, $height) = @_;
        my $piddle = zeros( byte, $bytes_per_pixel, $width, $height );
        my $pointer = $piddle-&gt;get_dataref();
        my $s = SDL::Surface-&gt;new_from(
            $pointer, $width, $height, 32,
            $width * $bytes_per_pixel
        );

        my $surface = SDLx::Surface-&gt;new( surface =&gt; $s );

        return ( $piddle, $surface );
    } 


    my ( $piddle, $surface ) = make_surface_piddle( 4, 400, 200 );

    $app-&gt;add_move_handler( sub {

            SDL::Video::lock_surface($surface);

            $piddle-&gt;mslice( &#39;X&#39;,
                [ rand(400), rand(400), 1 ],
                [ rand(200), rand(200), 1 ] 
                ) .= pdl( rand(225), rand(225), rand(225), 255 );

            SDL::Video::unlock_surface($surface);
            } );


    $app-&gt;add_show_handler( sub {

        $surface-&gt;blit( $app, [0,0,$surface-&gt;w,$surface-&gt;h], [10,10,0,0] );
        $app-&gt;update();

    });

    $app-&gt;run();</code></pre>

<h2>OpenGL and SDL</h2>

<p>OpenGL is a cross platform library for interactive 2D and 3D graphics
applications. However OpenGL specifies only the graphics pipeline and
doesn't handle inputs and events. SDL can hand over the graphics component
of an application over to OpenGL and take control over the event handling,
sound, and textures. In the first example we will see how to set up Perl's
<code>OpenGL</code> module with <code>SDLx::App</code>.</p>

<p>\includegraphics[width=0.5\textwidth]{../src/images/opengl-1.png}
\caption{The lovely blue teapot} \label{fig:opengl-1}</p>



<h3>SDL Setup</h3>

<pre><code>        use strict;
        use warnings;
        use SDL;
        use SDLx::App;

        use OpenGL qw/:all/;

        my $app = SDLx::App-&gt;new( 
                title  =&gt; &quot;OpenGL App&quot;,
                width  =&gt; 600,
                height =&gt; 600,
                gl     =&gt; 1,
                eoq    =&gt; 1
           );


        $app-&gt;run();</code></pre>

<p>Enabling <code>OpenGL</code> mode is as simple as adding the
<code>gl</code> flag to the <code>SDLx::App</code> constructor.</p>

<h3>OpenGL Setup</h3>

<p>Next we will make a <code>OpenGL</code> perspective with the
<code>$app</code>'s dimensions:</p>

<pre><code>        glEnable(GL_DEPTH_TEST);
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity;
        gluPerspective(60, $app-&gt;w/$app-&gt;h, 1, 1000 );
        glTranslatef( 0,0,-20);</code></pre>

<p>Additionally we will be initializing <code>glut</code>, but just to draw
something quick.</p>

<pre><code>        #Using glut to draw something interesting really quick
        glutInit();</code></pre>

<h3>The Render Callback</h3>

<p>Now we are prepared to put something on the screen.</p>

<pre><code>        $app-&gt;add_show_handler( 
                sub{
                        my $dt = shift;
                
                        #clear the screen
                        glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
                        glColor3d(0,1,1);

                        glutSolidTeapot(2); 

                        #sync the SDL application with the OpenGL buffer data
                        $app-&gt;sync;


                }
        );</code></pre>

<p>At this point there should be a light blue teapot on the screen. The
only special thing to notice here is that we need to call the
<code>sync()</code> method on <code>$app</code>. This will flush the
buffers and update the SDL application for us.</p>

<h3>Event handling</h3>

<p>Event handling is the same as any other <code>SDLx::App</code>. We will
use the mouse motion changes to rotate the teapot.</p>

<p>First add a global variable to hold your rotate values. And then use
those values to rotate our teapot.</p>

<pre><code>      glutInit();

    + my $rotate = [0,0];
     
      $app-&gt;add_show_handler( 
        sub{
        my $dt = shift;
    
        #clear the screen
        glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
        glColor3d(0,1,1);

    +   glPushMatrix();

        +       glRotatef($rotate-&gt;[0], 1,0,0);
    +   glRotatef($rotate-&gt;[1], 0,1,0);

        glutSolidTeapot(2); 

        #sync the SDL application with the OpenGL buffer data
        $app-&gt;sync;

   +    glPopMatrix();
        }
    );</code></pre>

<p>Next we will add an event handler to the app to update the rotate values
for us.</p>

<pre><code>    $app-&gt;add_event_handler(

        sub {
            my ($e ) = shift;

            if( $e-&gt;type == SDL_MOUSEMOTION )
                {
                    $rotate =   [$e-&gt;motion_x,  $e-&gt;motion_y];
                }

        }

    );</code></pre>

<p>Finally we run the application.</p>

<pre><code>    $app-&gt;run();</code></pre>

<h3>Complete Code</h3>

<pre><code>    use strict;
    use warnings;
    use SDL;
    use SDLx::App;
    use SDL::Event;

    use OpenGL qw/:all/;

    my $app = SDLx::App-&gt;new( 
            title  =&gt; &quot;OpenGL App&quot;,
            width  =&gt; 600,
            height =&gt; 600,
            gl     =&gt; 1,
            eoq    =&gt; 1
            );

    glEnable(GL_DEPTH_TEST);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity;
    gluPerspective(60, $app-&gt;w/$app-&gt;h, 1, 1000 );
    glTranslatef( 0,0,-20);
    glutInit();

    my $rotate = [0,0];

    $app-&gt;add_show_handler( 
            sub{
            my $dt = shift;

    #clear the screen
            glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
            glColor3d(0,1,1);

            glPushMatrix();

            glRotatef($rotate-&gt;[0], 1,0,0);
            glRotatef($rotate-&gt;[1], 0,1,0);

            glutSolidTeapot(2); 

    #sync the SDL application with the OpenGL buffer data
            $app-&gt;sync;

            glPopMatrix();
            }
            );

    $app-&gt;add_event_handler(

            sub {
            my ($e ) = shift;

            if( $e-&gt;type == SDL_MOUSEMOTION )
            {
            $rotate =   [$e-&gt;motion_x,  $e-&gt;motion_y];
            }

            }

            );

    $app-&gt;run();</code></pre>

<h1>Free Resources</h1>

<p>When developing a game, coding is unfortunately not everything. Not by a
very, very long shot. To make up (a little) for that, below is a list of
free resources you can use in your games, either in full or simply as
inspiration for your own productions, in case you have an artistic vein
yourself.</p>

<p>Make sure to check the licence for the resource and use it accordingly,
giving the original author proper credit.</p>

<p><b>Note:</b> websites come and go, so if you find any of the links
broken, or know a nice free resource that's not listed here, please let us
know so we can update the list.</p>

<h2>Art and Sprites</h2>

<ul>

<li>HTTP://CGTextures.Com</li>

<li>HTTP://Mayang.Com/textures</li>

<li>HTTP://GRSites.Com/archive/textures</li>

<li>HTTP://ImageAfter.Com</li>

<li>HTTP://AbsoluteCross.Com/graphics/textures</li>

<li>HTTP://FreeFoto.Com</li>

<li>HTTP://Noctua-Graphics.De</li>

<li>HTTP://M3Corp.Com/a/download/3d_textures/pages</li>

<li>HTTP://ReinersTileSet.4Players.De/englisch.html</li>

<li>HTTP://VirtualWorlds.Wikia.Com</li>

<li>HTTP://Lunar.LostGarden.Com/labels/free%20game%20graphics.html</li>

<li>HTTP://PDGameResources.WordPress.Com</li>

<li>HTTP://GamingGroundZero.Com</li>

<li>HTTP://FlyingYogi.Com/fun/spritelib.html</li>

<li>HTTP://PixelPoke.Com</li>

</ul>

<h2>Music and Sound Effects</h2>

<ul>

<li>HTTP://FreeSound.Org</li>

<li>HTTP://CCMixter.Org</li>

<li>HTTP://Jamendo.Com</li>

<li>HTTP://8BC.Org</li>

<li>HTTP://Sakari-Infinity.Net</li>

<li>HTTP://FindSounds.Com</li>

<li>HTTP://GRSites.Com/archive/sounds</li>

</ul>

<h2>Fonts</h2>

<ul>

<li>HTTP://DAFont.Com</li>

<li>HTTP://FontSquirrel.Com</li>

<li>HTTP://TheLeagueOfMoveableType.Com</li>

<li>HTTP://OpenFontLibrary.Org</li>

<li>HTTP://AcidFonts.Com</li>

<li>HTTP://GRSites.Com/archive/fonts</li>

<li>HTTP://UrbanFonts.Com</li>

</ul>

<h2>DIY</h2>

<p>HTTP://GameSoundDesign.Com has several tips on making game music,
including several sources for inspiration.</p>

<p>If you want to create 3D models, either for cutscenes or to integrate
into your game via OpenGL, there are several nice libraries out there for
you:</p>

<p><b>Blender</b> - A free 3D graphics application for modeling, texturing,
water and smoke simulations, rendering, etc. HTTP://Blender.Org</p>

<p><b>OGRE</b> - An open-source graphics rendering engine, used in a large
number of production projects. It can be easily integrated via Scott
Lanning's <i>Ogre</i> Perl bindings, on CPAN. HTTP://Ogre3D.Org</p>

<h2>Author</h2>

<p>This chapter's content graciously provided by Breno G. de Oliveira
(<code>garu</code>).</p>

